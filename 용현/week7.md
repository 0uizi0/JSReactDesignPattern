## 12. 4 리액트 Hooks 패턴

- Hooks를 사용하면 ES2015의 클래스 컴포넌트를 사용하지 않고도 상태와 라이프사이클 메서드를 활용할 수 있다.
- Hooks 자체는 디자인 패턴이라고 할 수 없지만, 애플리케이션 설계에서 중요한 역할을 하고 많은 전통적인 디자인 패턴을 대체할 수 있다.

### 12.4.1 클래스 컴포넌트

- 리액트에 Hooks가 도입되기 전에는, 컴포넌트에 상태와 라이프사이클 메서드를 추가하려면 클래스 컴포넌트를 사용해야만 했다.
- 클래스 컴포넌트의 특징
  - 생성자 함수 내의 상태
  - 컴포넌트 라이프사이클에 따른 효과를 처리하기 위한 componentDidMount, componentWillUnmount와 같은 라이프사이클 메서드
  - 추가적인 로직을 구현하기 위한 커스텀 메서드

### 12.4.2 구조 변경의 필요성

- 여러 컴포넌트 간에 코드를 공유하는 일반적인 방법은 고차 컴포넌트 또는 렌더링 Props 패턴을 사용하는 것이다.
- 하지만 컴포넌트가 클수록 이러한 구조 변경이 더 까다로워질 뿐만 아니라, 깊게 중첩된 컴포넌트간에 코드를 공유하기 위해 여러 겹의 컴포넌트를 사용하다 보면 `래퍼 헬` 이라고 불리는 상황에 빠질 수도 있다.
- `래퍼 헬` 은 애플리케이션 내 데이터 흐름을 파악하기 어렵게 만들어 예상치 못한 동작의 원인을 찾기 어렵게 만든다.

### 12.4.3 복잡성 증가

- 클래스 컴포넌트에 더 많은 로직을 추가할수록 컴포넌트의 크기는 빠르게 증가한다.
- 컴포넌트 내부의 로직은 얽히고 구조화되지 않을 수 있으며, 개발자는 특정 로직이 클래스 컴포넌트의 어디에서 사용되는지 이해하기 어려워진다.
- 이러한 복잡성 증가 현상이 디버깅과 성능 최적화를 더욱 어렵게 만들며 라이프사이클 메서드 또한 상당한 중복 코드를 발생시키기도 한다.

### 12.4.4 Hooks

- 리액트 Hooks는 컴포넌트의 상태와 라이프사이클 메서드를 관리할 때 사용할 수 있는 함수이다.
- 리액트 Hooks를 사용하면 다음과 같은 구현이 가능하다.
  - 함수형 컴포넌트에 상태 추가하기
  - componentDidMount, componentWillUnmount 같은 라이프사이클 메서드를 사용하지 않고도 컴포넌트의 라이프사이클 관리하기
  - 여러 컴포넌트 간에 동일한 상태 관련 로직 재사용하기

## 12.5 상태 Hook

- 리액트는 함수형 컴포넌트 내에서 상태를 관리하는 useStaste라는 Hook을 제공한다.

### 12.5.1 이펙트 Hook

- useEffect Hook을 사용하면 컴포넌트의 라이프사이클에 접근할 수 있다.
- useEffect Hook은 componentDidMount, componentDidUpdate, componentWillUnmount 라이프사이클 메서드를 하나로 합쳐 사용할 수 있다.

### 12.5.2 커스텀 Hook

- 리액트에서 기본적으로 제공하는 Hooks 외에도 직접 커스텀 Hook을 손쉽게 만들어 사용할 수 있다.
- Hook 사용 규칙을 잘 따르고 있는지 리액트가 내부적으로 판단하기 위해서는 반드시 use로 시작해야한다.
- Hook의 또 다른 큰 장점은 누구나 Hook을 만들고 공유할 수 있다는 점이다.
- 커스텀 Hook 목록을 제공하는 서비스
  - React Use
  - useHooks
  - Collection of React Hooks

### 12.5.3 Hook 관련 추가 정보

- useState
- useEffect
- useContext
- useReducer

### 12.5.4 Hook의 장단점

- Hook을 사용하면 얻는 이점
  - 더 적은 코드 라인 수
    - Hook을 사용하면 코드를 라이프사이클 별로 나누지 않고, 관심사 및 기능별로 그룹화 할 수 있다.
    - 이러한 특징은 코드를 더욱 깔끔하고 간결하게 만들 뿐만 아니라, 전체 코드 길이도 줄일 수 있게 해준다.
  - 복잡한 컴포넌트의 단순화
    - 자바스크립트의 클래스는 관리가 어렵고, 핫 리로딩과 함께 사용하기 힘들며 코드 경량화가 어려울 수 있다.
    - Hook은 이러한 문제를 해결하고 함수형 프로그래밍을 쉽게 구현할 수 있게 도와준다.
  - 상태 관련 로직 재사용
    - 자바스크립트의 클래스는 여러 단계에 걸친 상속 때문에 전체적인 복잡성을 높이고 에러 발생 가능성을 증가시킬 수 있다.
    - 하지만 Hook을 사용하면 클래스를 작성하지 않고도 상태와 함께 리액트의 다른 기능을 사용할 수 있기 때문에 언제든지 상태관련 로직을 재사용할 수 있으며, 코드를 반복해서 작성할 필요가 없다.
    - 이는 에러발생 가능성을 줄이고, Hook으로 만들어진 순수 함수를 이용해 더욱 복잡한 로직을 구현할 수 있게 한다.
  - UI에서 분리된 로직 공유
    - Hook이 도입되기 전에는 리액트에서 UI와 무관한 로직을 추출하고 공유할 방법이 없었다.
    - 이로 인해 고차 컴포넌트 패턴이나 렌더링 Props와 같은 복잡한 방법을 동완해야만 했다.
    - 하지만 Hook의 등장으로 상태 관련 로직을 단순하 ㄴ자바스크립트 함수로 추출할 수 있게 해주며 문제를 해결할 수 있었다.
  - Hook을 사용할 때 주의해야 할 단점
    - Hook 사용 규칙을 준수해야 한다.
    - 올바르게 사용하려면 상당한 연습이 필요하다.
    - 잘못된 사용에 주의해야 한다.

### 12.5.5 Hook vs Class

- Hook과 클래스의 차이점
  - Hook은 복잡한 계층 구조를 피하고 코드를 더 명확하게 만든다. 일반적으로 클래스에서 고차 컴포넌트나 렌더링 Props 패턴을 사용하면 리액트 개발자 도구에서 여러 계층에 걸쳐 애플리케이션 구조를 파악해야 한다.
  - Hook은 리액트 컴포넌트 전체에 일관성을 부여한다. 클래스는 함수 바인딩과 호출 컨텍스트를 이해해야 하기 때문에 사람과 기계 모두에게 혼란을 줄 수 있다.

## 12.6 정적 가져오기

- import 키워드를 사용하면 다른 모듈에서 내보낸 코드를 가져올 수 있다.

## 12.7 동적 가져오기

- 리액트의 Suspense 기능을 사용한다면 손쉽게 동적으로 가져올 수 있다.
- 초기 번들 크기가 작아지면 초기 로딩 속도가 빨라지게 된다.

## 12.8 코드 스플리팅

- 여러 경로와 컴포넌트로 구성된 복잡한 애플리케이션에서는 적절한 시기에 정적 및 동적 임포트가 모두 가능하도록 코드를 최적으로 스플리팅(분할)하고 번들링해야 한다.
- 이를 위해서는 경로 기반 분할을 사용하거나, 웹팩이나 롤업과 같은 최신 번들러를 사용하여 애플리케이션 소스 코드를 분할하고 번들링할 수 있다.

### 12.8.1 경로 기반 분할

- 때로는 특정 페이지나 경로에서만 필요한 리소스가 있을 수 있다. 이런 경우, 경로 기반 분할을 통해 특정 경로에 필요한 리소스만 요청할 수 있다.
- 경로별로 컴포넌트를 지연 로딩하면, 현재 경로에 필요한 코드가 포함된 번들만 요청하게 된다.
- 페이지 이동 시 로딩 시간이 다소 걸릴 수 있다는 점은 이미 많은 사람에게 익숙하기 때문에, 페이지 이동 시 컴포넌트를 지연 로딩하는 것은 자연스러운 방법이다.

### 12.8.2 번들 분할

- 최신 웹 애플리케이션을 개발할 때 웹팩 또는 롤업과 같은 번들러는 애플리케이션의 소스 코드를 하나 이상의 번들 파일로 묶는다.
- 사용자가 웹사이트를 방문하면, 필요한 데이터와 기능을 표시하기 위한 특정 번들이 요청되고 로드된다.
- 사용자에게 최대한 빨리 데이터를 보여주는 것은 중요하다. 번들의 크기가 커지면 로딩, 처리, 실행 시간이 모두 늘어나게 된다. 따라서 번들 크기를 줄여 속도를 높일 수 있다면 좋을 것이다.
- 그렇다면 불필요한 코드를 포함하는 거대한 번들 하나를 요청하는 대신, 번들을 여러 개의 작은 번들로 분할하는 방법을 사용할 수도 있다.

## 12.9 PRPL 패턴

- 저사양 기기나 인터넷 연결이 불안정한 지역에서도 애플리케이션이 원활하게 작동해야 하기 때문에 이러한 어려운 환경에서도 애플리케이션이 최대한 효율적으로 로드 될 수 있도록 하려면 PRPL 패턴을 사용할 수 있다.
- PRPL 패턴은 다음 네 가지 핵심 성능 고려사항에 중점을 둔다
  - 푸시 : 중요한 리소스를 효율적으로 푸시하여 서버 왕복 횟수를 최소화하고 로딩 시간을 단축한다.
  - 렌더링 : 사용자 경험을 개선하기 위해 초기 경로를 최대한 빠르게 렌더링한다.
  - 사전 캐싱 : 자주 방문하는 경로의 에셋을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄이고 더 나은 오프라인 경험을 제공한다.
  - 지연 로딩 : 자주 요청되지 않는 경로나 에셋은 지연 로딩한다.

## 12.10 로딩 우선순위

- 로딩 우선순위 패턴은 필요하다고 예상되는 특정 리소스를 우선적으로 요청하도록 설정한다.
- Preload는 브라우저의 최적화 기능으로, 브라우저가 늦게 요청 할 수도 있는 중요한 리소스를 더 일찍 요청할 수 있도록 한다.
- 주요 리소스의 로딩 순서를 수동으로 지정한다면, 핵심 웹 지표의 로딩 성능 및 지표에 긍정적인 영향을 미칠 수 있다.
- 만약 자바스크립트 자체의 로딩을 최적화하려면, body 태그보다는 head 태그 안에서 script defer 을 사용하는 것이 해당 리소스를 초기에 로딩하는 데 도움이 될 수 있다.

### 12.10.1 SPA의 Preload

- Prefetching은 곧 요청될 가능성이 있는 리소스를 캐시하는 좋은 방법이지만, 즉시 사용해야 하는 리소스의 경우에는 preload를 사용할 수 있다.

### 12.10.2 Preload + async 기법

- 브라우저가 스크립트를 높은 우선순위로 다운로드하면서도, 스크립트를 기다리는 동안 파싱이 멈추지 않도록 하려면 Preload + async 기법을 활용할 수 있다.
- 이 경우 preload는 다른 리소스의 다운로드를 지연시킬 수 있지만, 얻을 수 있는 이점을 위해서 감수해야 하는 트레이드오프이다.

### 12.10.3 크롬 95+ 버전에서의 Preload

- 크롬 95+에서는 preload의 큐 점핑 동작이 개선되어 Preload 기능이 더 안전해졌다.
- 크롬 개발자가 preload에 대해 제시하는 사용 권장사항
  - HTTP 헤더에 preload를 넣으면 다른 모든 리소스보다 우선적으로 로드된다.
  - 일반적으로 중간 레벨 이상의 우선순위를 가진 preload는 파서가 HTML을 처리하는 순서대로 로드되므로, HTML 시작 부분에 preload를 넣을 때 주의해야 한다.
  - 미리 로드되는 폰트는 head 태그 끝 부분이나 body 태그 시작 부분에 넣는 것이 가장 좋다.
  - 미리 로드되는 모듈을 가져오는 건 실제 스크립트가 먼저 로드/파싱되도록 해당 가져오기가 필요한 script 태그 다음에 위치해야 한다.
  - 이미지 preload는 기본적으로 우선순위가 낮으며, 비동기 스크립트 및 기타 낮은/최저 우선순위 태그와 관련하여 순서를 지정해야 한다.

## 12.11 리스트 가상화

- 리스트 가상화는 대규모 데이터 리스트의 렌더링 성능을 향상시키는 기술이다.
- 전체 목록을 모두 렌더링하는 대신 현재 화면에 보이는 행만 동적으로 렌더링한다.

### 12.11.1 윈도잉/가상화의 작동 방식

- 사용자가 스크롤할 때마다 이전 항목을 윈도우에서 제거하고 새로운 항목으로 대체하면서 더 많은 항목을 가져와 표시하게 된다.

### 12.11.2 List 컴포넌트

- List 컴포넌트는 윈도잉된 리스트의 아이템을 렌더링한다.

### 12.11.3 Grid 컴포넌트

- Grid 컴포넌트는 수직 및 수평 방향으로 가상화된 표 형태의 데이터를 렌더링한다.
- 수평/수직의 현재 스크롤 위치에 따라 필요한 Grid 셀만 렌더링한다.

## 12.12 결론

- preload는 신중하게 사용해야 하며 항상 프로덕션 환경에 미칠 영향을 측정해야 한다.
- 이미지 preload가 문서에서 앞쪽에 위치하면 브라우저가 해당 이미지를 더 빨리 발견하고 다른 리소스와의 로딩 순서를 조정하는 데 도움이 될 수 있다.
- 하지만 preload를 잘못 사용하면 FCP에 필수적인 리소스를 지연시켜 원하는 것과 정반대의 결과를 초래할 수 있다.
- 또한 이러한 리소스 로딩 우선순위 조정이 제대로 효과를 발휘하려면 서버 사이드에서도 요청 우선순위를 올바르게 처리해야 한다.

### 이야기 해볼 내용

- Hooks 라이브러리 사용해대해 의견이 좀 갈리던데 어떻게 생각하시나요?
- PRPL 패턴을 사용해보신 경험이 있으신가요?
