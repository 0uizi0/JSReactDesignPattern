# 9. 비동기 프로그래밍 패턴

## 9.1 비동기 프로그래밍

- 동기 코드는 블로킹 방식으로 실행되며 이는 코드가 순서대로 한번에 한 문장씩 실행됨을 의미한다.
- 비동기 코드는 논블로킹 방식으로 실행되며 이는 현재 실행 중인 코드가 다른 작업을 기다리는 동안 백그라운드에서 해당 비동기 코드를 실행할 수 있음을 의미한다.

## 9.2 배경

- 콜백 사용할 때의 주요 단점
  - 콜백 지옥으로 불리는 상황을 초래할 수 있다.
  - 콜백 지옥은 중첩된 콜백 구조로 인해 코드의 가독성과 유지보수성이 크게 저하되는 상황을 뜻한다.

## 9.3 프로미스 패턴

- 프로미스를 사용할 때의 주요 장점
  - 콜백보다 체계적이고 가독성이 높은 방법으로 비동기 작업을 처리할 수 있다.
  - 이를 통해 콜백 지옥을 피하고 이해하기 쉽고 유지보수성이 높은 코드를 작성할 수 있다.

### 9.3.1 프로미스 체이닝

- 프로미스 체이닝 패턴을 사용하면 여러 개의 프로미스를 함께 연결하여 보다 복잡한 비동기 로직을 만들 수 있다.

### 9.3.2 프로미스 에러 처리

- 프로미스 에러 처리 패턴은 catch 메서드를 사용하여 프로미스 체인의 실행 중에 발생할 수 있는 에러를 처리한다.

### 9.3.3 프로미스 병렬 처리

- 프로미스 병렬 처리 패턴은 Promise.all 메서드를 사용하여 여러 프로미스를 동시에 실행할 수 있게 해준다.

### 9.3.4 프로미스 순차 실행

- 프로미스 순차 실행 패턴은 Promise.resolve 메서드를 사용하여 프로미스를 순차적으로 실행할 수 있도록 해준다.

### 9.3.5 프로미스 메모이제이션

- 프로미스 메모이제이션 패턴은 캐시를 사용하여 프로미스 함수 호출의 결과값을 저장하며 이를 통해 죽복된 요청을 방지할 수 있다.

### 9.3.6 프로미스 파이프라인

- 프로미스 파이프라인 패턴은 프로미스와 함수형 프로그래밍 기법을 활용하여 비동기 처리의 파이프라인을 생성한다.

### 9.3.7 프로미스 재시도

- 프로미스 재시도 패턴을 사용하면 프로미스가 실패할 때 다시 시도할 수 있다.

### 9.3.8 프로미스 데코레이터

- 프로미스 데코레이터 패턴은 고차 함수를 사용하여 프로미스에 적용할 수 있는 데코레이터를 생성한다.

### 9.3.9 프로미스 경쟁

- 프로미스 경쟁 패턴은 여러 프로미스를 동시에 실행하고 가장 먼저 완료되는 프로미스의 결과를 반환한다.

## 9.4 async/await 패턴

- async/await는 프로미스를 기반으로 구축되었으며 비동기 코드 작업을 보다 쉽고 간결하게 만들어준다.

### 9.4.1 비동기 함수 조합

- 비동기 함수 조합 패턴은 여러 비동기 함수를 조합하여 보다 복잡한 비동기 로직을 구성하는 것을 의미한다.

### 9.4.2 비동기 반복

- 비동기 반복 패턴은 for-await-of 반복문을 사용하여 비동기 반복 가능 객체를 순회할 수 있도록 한다.

### 9.4.3 비동기 에러 처리

- 비동기 에러 처리 패턴은 try-catch 블록을 사용하여 비동기 함수 실행 도중 발생할 수 있는 에러를 처리한다.

### 9.4.4 비동기 병렬

- 비동기 병렬 패턴은 Promise.all 메서드를 사용하여 여러 비동기 작업을 동시에 실행할 수 있게 한다.

### 9.4.5 비동기 순차 실행

- 비동기 순차 실행 패턴은 Promise.resolve 메서드를 사용하여 비동기 작업을 순차적으로 실행할 수 있도록 한다.

### 9.4.6 비동기 메모이제이션

- 비동기 메모이제이션 패턴은 캐시를 사용해 비동기 함수 호출 결과를 저장하여 중복 요청을 방지할 수 있다.

### 9.4.7 비동기 이벤트 처리

- 비동기 이벤트 처리 패턴은 비동기 함수를 사용하여 이벤트를 처리할 수 있도록 한다.

### 9.4.8 async/await 파이프라인

- async/await 파이프라인 패턴은 async/await와 함수형 프로그래밍 기법을 활용하여 비동기 변환 작업들의 파이프라인을 생성한다.

### 9.4.9 비동기 재시도

- 비동기 재시도 패턴을 사용하면 비동기 작업이 실패해도 자동으로 재시도할 수 있다.

### 9.4.10 async/await 데코레이터

- async/await 데코레이터 패턴은 고차함수를 사용하여 데코레이터를 생성한다.

# 이야기 할 내용

- Promise: .catch()를 통해 에러 처리.
- Async/Await: try/catch 블록 사용.

- 어떤 에러 핸들링 방식이 더 직관적이라고 생각하는지?
- 네트워크 요청이나 Web API 작업에서 어떤 전략이 더 적합할까?
