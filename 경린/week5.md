# 9. 비동기 프로그래밍 패턴

## 9.1 비동기 프로그래밍

-   동기 코드

    블로킹 방식으로 실행

    이는 코드가 순서대로 한번에 한 문장씩 실행됨을 의미

-   비동기 코드

    논블로킹 방식

    이는 현재 실행 중인 코드가 다른 작업을 기다리는 동안 백그라운드에서 해당 비동기 코드를 실행할 수 있음을 의미

### 콜백 지옥

-   콜백 지옥은 중첩된 콜백 구조로 인해 코드의 가독성과 유지보수성이 크게 저하되는 상황

## 9.3 프로미스 패턴

-   비동기 작업의 결과를 나타내는 객체
-   대기, 완료, 거부 세가지 상태

-   콜백보다 체계적이고 가독성이 높은 방법으로 비동기 작업을 처리할 수 있다.
-   이해하기 쉽고 유지보수성이 높은 코드를 작성할 수 있다.

### 9.3.1 프로미스 체이닝

-   프로미스 체이닝 패턴을 사용하면 여러 개의 프로미스를 함께 연결하여 보다 복잡한 비동기 로직을 만들 수 있다.

### 9.3.2 프로미스 에러 처리

-   프로미스 에러 처리 패턴은 catch 메서드를 사용하여 프로미스 체인의 실행 중에 발생할 수 있는 에러를 처리한다.

### 9.3.3 프로미스 병렬 처리

-   프로미스 병렬 처리 패턴은 Promise.all 메서드를 사용하여 여러 프로미스를 동시에 실행할 수 있게 해준다.

### 9.3.4 프로미스 순차 실행

-   프로미스 순차 실행 패턴은 Promise.resolve 메서드를 사용하여 프로미스를 순차적으로 실행할 수 있도록 해준다.

### 9.3.5 프로미스 메모이제이션

-   캐시를 사용하여 프로미스 함수 호출의 결과값을 저장하며 이를 통해 중복된 요청을 방지할 수 있다.

### 9.3.6 프로미스 파이프라인

-   프로미스 파이프라인 패턴은 프로미스와 함수형 프로그래밍 기법을 활용하여 비동기 처리의 파이프라인을 생성한다.

### 9.3.7 프로미스 재시도

-   프로미스 재시도 패턴을 사용하면 프로미스가 실패할 때 다시 시도할 수 있다.

### 9.3.8 프로미스 데코레이터

-   프로미스 데코레이터 패턴은 고차 함수를 사용하여 프로미스에 적용할 수 있는 데코레이터를 생성한다.

### 9.3.9 프로미스 경쟁

-   프로미스 경쟁 패턴은 여러 프로미스를 동시에 실행하고 가장 먼저 완료되는 프로미스의 결과를 반환한다.

## 9.4 async/await 패턴

-   비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 자바스크립트 기능

### 9.4.1 비동기 함수 조합

-   비동기 함수 조합 패턴은 여러 비동기 함수를 조합하여 보다 복잡한 비동기 로직을 구성하는 것을 의미한다.

### 9.4.2 비동기 반복

-   비동기 반복 패턴은 for-await-of 반복문을 사용하여 비동기 반복 가능 객체를 순회할 수 있도록 한다.

### 9.4.3 비동기 에러 처리

-   비동기 에러 처리 패턴은 try-catch 블록을 사용하여 비동기 함수 실행 도중 발생할 수 있는 에러를 처리한다.

### 9.4.4 비동기 병렬

-   비동기 병렬 패턴은 Promise.all 메서드를 사용하여 여러 비동기 작업을 동시에 실행할 수 있게 한다.

### 9.4.5 비동기 순차 실행

-   비동기 순차 실행 패턴은 Promise.resolve 메서드를 사용하여 비동기 작업을 순차적으로 실행할 수 있도록 한다.

### 9.4.6 비동기 메모이제이션

-   비동기 메모이제이션 패턴은 캐시를 사용해 비동기 함수 호출 결과를 저장하여 중복 요청을 방지할 수 있다.

### 9.4.7 비동기 이벤트 처리

-   비동기 이벤트 처리 패턴은 비동기 함수를 사용하여 이벤트를 처리할 수 있도록 한다.

### 9.4.8 async/await 파이프라인

-   async/await 파이프라인 패턴은 async/await와 함수형 프로그래밍 기법을 활용하여 비동기 변환 작업들의 파이프라인을 생성한다.

### 9.4.9 비동기 재시도

-   비동기 재시도 패턴을 사용하면 비동기 작업이 실패해도 자동으로 재시도할 수 있다.

### 9.4.10 async/await 데코레이터

-   async/await 데코레이터 패턴은 고차함수를 사용하여 데코레이터를 생성한다.

### 10 모듈형 자바스크립트 디자인 패턴

next.config.js에서 사용하는 module.exports 이 commonjs패턴인데 최근 ESModules 이 도입되면서 최신 next에선 
```
const nextConfig = {
  /* config options here */
}
export default nextConfig
```
next.config.mjs로 사용됨




### 이야깃거리

이렇게 비동기 패턴이 많은 줄 몰랐는데 신기하네요

이런 재시도 전략은 어떨 때 사용하는 게 유용할까요? 생각으론 어차피 실패할 거 3번 반복해도 다시 성공할 확률이 적을 것 같은데,,? 그래도 안정성을 위해서?

```
function makeRequestWithRetry(url) {
  let attempts = 0;

  const makeRequest = () => new Promise((resolve, reject) => {
    fetch(url)
      .then(response => response.json())
      .then(data => resolve(data))
      .catch(error => reject(error));
  });

  const retry = error => {
    attempts++;
    if (attempts >= 3) {
      throw new Error('Request failed after 3 attempts.');
    }
    console.log(`Retrying request: attempt ${attempts}`);
    return makeRequest();
  };

  return makeRequest().catch(retry);
}
```
