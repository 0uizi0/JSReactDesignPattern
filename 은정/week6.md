# 11강. 네임스페이스 패턴
## 정리
- 네임스페이스는 코드 단위를 고유한 식별자로 그룹화한 것을 뜻한다

#### 네임스페이스의 필요성
- 전역 네임스페이스에 존재하는 다른 객체나 변수와의 충돌을 방지함에 있어 유용하다
- 코드의 재사용성과 관리의 편의성을 높여준다
- 페이지 내 다른 스크립트와 변수 또는 메서드의 이름이 **충돌**하여 코드가 실행되지 않는 문제를 방지하기 위해서라도 반드시 필요하다

#### 네임스페이스 패턴의 종류
- 단일 전역 변수
- 접두사 네임스페이스
- 객체 리터럴 표기법
- 중첩 네임스페이스
- 즉시 실행 함수 표현식

### 단일 전역 변수 패턴
- 하나의 전역 변수를 주요 참조 객체로 사용하는 방식
- 특정한 상황에서는 유용할 수 있지만, 가장 큰 문제점은 다른 개발자가 같은 이름의 전역 변수를 이미 사용하고 있을 가능성이 있다는 것이다

### 접두사 네임스페이스 패턴
- 전역에서 특정 변수와 이름이 겹칠 가능성을 효과적으로 줄인다
- 가장 큰 문제점은 애플리케이션이 커짐에 따라 많은 전역 객체가 생성된다는 점이다
- 먼저 고유한 접두사(예: myApplication_)을 선정한 다음에 모든 메서드, 변수, 객체를 이 접두사 뒤에 붙여서 정의한다
```js 
const myApplication_propertyA = {};
const myApplication_propertyB = {};
function myApplication_myMethod() {
  // ...
}
```

### 객체 리터럴 표기법 패턴
- 일종의 객체로, 키와 값으로 이뤄진 집합을 가지며, 각각의 키와 값은 콜론(:)으로 구분된다
  - 키-값 구조이기에 손쉽게 알아볼 수 있다
  - 덕분에 애플리케이션 내의 서로 다른 로직이나 기능을 쉽게 캡슐화하여 깔끔하게 분리하고, 코드 확장에 있어 든든한 기반을 제공한다
- 또한 키 자체가 새로운 네임스페이스가 될 수 있다
- 전역 네임스페이스를 오염시키지 않으면서도 코드와 매개변수를 논리적으로 구성하는 데 도움을 준다
- 특히 쉽게 읽을 수 있고, 깊은 중첩까지 지원하는 구조를 구현할 때 매우 유용하다
- 또한 객체 리터럴 표기법 패턴은 일반적은 전역 변수들과 달리 동일한 이름의 변수가 있는지 검사하도록 설계되는 경우가 많아 충돌 가능성을 크게 줄여준다

### 중첩 네임스페이스 패턴
- 객체 리터럴 패턴을 발전시킨 형태이다
- 비록 같은 이름의 네임스페이스가 존재한다고 하더라도, 하위에 중첩된 네임스페이스까지 정확하게 일치할 가능성이 낮기 때문에 다른 패턴에 비해 **충돌 위험이 낮다**

### 즉시 실행 함수 표현식 패턴
- 즉시 실행 함수는 정의 직후 바로 실행되는, 이름이 없는 함수이다
- 자바스크립트에서는 즉시 실행 함수로 정의된 내부의 변수와 함수 모두 외부에서 접근할 수 없다
- 따라서 함수를 호출하는 것만으로도 쉽게 코드의 은닉성을 구현할 수 있다
- 즉시 실행 함수는 애플리케이션의 로직을 캡슐화하여 전역 네임스페이스로부터 보호하는 데 널리 사용되는 방법이다
- 명확한 범위의 접근권한(public/private 함수나 변수)과 편리한 네임스페이스 확장 기능 등을 추가할 수 있다
- 확장성은 모든 네임스페이스 패턴에서 중요한 요소이다. 즉시 실행 함수를 사용하면 확장성을 비교적 쉽게 구현할 수 있다

### 네임스페이스 주입 패턴
- 즉시 실행 함수 패턴의 또 다른 변형이다
- 함수 내에서 this를 네임스페이스의 프록시로 활용하여 특정 네임스페이스에서 메서드와 속성을 '주입'한다

#### 장점
- 여러 객체나 네임스페이스에 기능적인 동작을 쉽게 적용할 수 있다
- 이후에 확장될 기본 메서드(예: 게터와 세터)에 적용할 때 유용하다
#### 단점
- 같은 목적을 달성하는 더 쉽고 효율적인 방법(예: 객체 확장 또는 병합)이 존재할 수 있다
#### 주의
- 일반적인 즉시 실행 함수에도 이 확장 기법을 적용할 수 있다
- context를 인자로 받아서 'this' 대신 해당 context를 직접 수정하면 된다

이전에도 앵거스 크롤은 컨텍스트와 인자를 자연스럽게 분리하고자 `apply API`와 `call API`를 사용하기도 했다

이러한 유형의 패턴은 여러 모듈이나 네임스페이스에 비슷한 기본 기능들을 할당할 때 유용하다

하지만 객체/클로저 내에서 명시적으로 기능을 선언할 때 직접 접근하는 것이 불가능한 상황에서만 사용하는 것을 추천한다

### 고급 네임스페이스 패턴
#### 중첩 네임스페이스 자동화 패턴
- 중첩 네임스페이스는 코드에 체계적이고 계층적인 구조를 만들어주지만, 추가하는 계층이 늘어날수록 최상위 네임스페이스에 더 많은 하위 객체들이 정의되어야 한다는 점이 단점이다
- 특히 애플리케이션이 복잡해져서 중첩의 깊이가 커질수록 매우 번거로워질 수 있는 작업이다
- 중첩 네임스페이스 자동화 패턴은, 하나의 문자열 인자를 받아서 파싱한 뒤에 필요한 객체를 기반 네임스페이스에 자동으로 추가하는 간편한 방법이다
```js 
const myApp = {};

function extend(ns, nsString) {
  const parts = nsString.split(".");
  let parent = ns;
  let pl;

  pl = parts.length;

  for (let i = 0; i < pl; i++) {
    if (typeof parent[parts[i]] === "undefined") {
      parent[parts[i]] = {};
    }

    parent = parent[parts[i]];
  }

  return parent;
}

// myApp에 깊게 중첩된 네임스페이스를 확장한다
const mod = extend(myApp, "modules.module2");

// 올바르게 중첩된 객체를 출력한다
console.log(mod);

// mod 인스턴스는 myApp 네임스페이스 밖에서도 확장된
// 클론 객체로 사용할 수 있는지 확인한다
console.log(mod === myApp.modules.module2); // true

// extend를 사용하여 더 쉽게 중첩 네임스페이스를 할당하는 또 다른 예시이다
extend(myApp, "moduleA.moduleB.moduleC.moduleD");
extend(myApp, "longer.version.looks.like.this");
console.log(myApp);
```

#### 의존성 선언 패턴
- 중첩 네임스페이스 패턴을 약간 변형한 형태이다
- 로컬 변수를 사용하는 것이 전역 변수(예: myApp)를 매번 사용하는 것보다 더 빠르다.
  - 더 편리하고 성능이 뛰어나며, 복잡한 애플리케이션에서는 가독성을 높일 수 있다
- 스토얀은 함수나 모듈에서 사용할 로컬 네임스페이스를 함수 영역의 상단에 선언할 것을 권장하며(단일 변수 패턴 사용), 이 방식을 의존성 선언 패턴이라고 부른다
  - 의존성을 찾고 해석하는 시간을 줄이는 장점이 있다
  - 필요할 때 동적으로 모듈을 네임스페이스에 추가하는 확장 가능한 아키텍처를 사용하는 경우에도 효과적이다
- 저자는 의존성 선언 패턴은 모듈 단위로 작업할 때 가장 효과적이라고 주장한다
  - 이 패턴은 특정 메서드 그룹에서 사용될 네임스페이스를 지역화한다
  - 다만 네임스페이스 간의 의존성이 중복되는 경우가 많다면 함수 단위로 네임스페이스를 지역화하는 것은 피하는 것이 좋다
  - 차라리 네임스페이스를 상위 레벨에서 정의하고 모든 함수가 접근할 수 있도록 하는 것이 더 바람직하다

#### 심층 객체 확장 패턴
- 자동 네임스페이스 생성에 대한 또 다른 해결책이다
- 객체 리터럴 표기법으로 선언된 네임스페이스는 다른 객체(또는 네임스페이스)와 쉽게 확장(또는 병합)될 수 있다
- 병합 이후에는 두 네임스페이스의 속성과 함수 모두를 동일한 네임스페이스에서 접근할 수 있다

### 권장하는 패턴
- 즉시 실행 함수 표현식 패턴과 단일 전역 변수 패턴은 중소 규모의 애플리케이션에서는 잘 작동할 수 있다
- 하지만 네임스페이스의 심층 하위 네임스페이스가 모두 필요한 대규모 코드베이스의 경우에는 가독성과 확장성을 높여주는 보다 간결한 해결책이 필요하다
- 객체 리터럴을 사용한 중첩 네임스페이스 패턴을 사용한다면 모두 해결할 수 있는 문제이다
