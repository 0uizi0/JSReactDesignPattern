# 5장. 최신 자바스크립트 문법과 기능

## 5.1 애플리케이션 분리의 중요성

- `모듈형` : 잘게 분리된 모듈로 구성되었음
- 모듈형을 통해 이루어진 느슨한 결합은 **의존성**을 낮추어 애플리케이션의 유지보수를 용이하게 만든다.

## 5.2 모듈 가져오기와 내보내기

- 모듈을 사용하면 각 기능에 맞는 독립적인 단위로 코드를 분리할 수 있다.
- 또한 모듈은 코드의 재사용성을 높여 다른 애플리케이션에도 같은 기능을 적용할 수 있게 한다.
- import문을 이용하면 내보내기된 모듈을 지역 변수로 가져올 수 있으며, 기존 변수명과의 충돌을 피하고자 이름을 바꿔서 가져올 수도 있다.
- export문을 이용하면 지역 모듈을 외부에서 읽을 수 있지만 수정할 수는 없도록 만들어준다.

## 5.5 정적으로 모듈 가져오기

- 정적 가져오기는 메인 코드를 실행하기 전에 먼저 모듈을 다운로드하고 실행해야 한다.
- 따라서 초기 페이지 로드 시 많은 코드를 미리 로드해야 하므로 성능에 문제가 생길 수도 있다.

## 5.6 동적으로 모듈 가져오기

- 모듈을 초기에 모두 미리 로드하기보다는 필요한 시점에만 로드하는 것이 더 이로울 때가 있다.
- 지연 로딩 모듈을 사용하면 필요한 시점에 로드할 수 있다
- 예를 들어 초기 로딩 시간을 줄일 수 있다.
- import(url)는 요청된 모듈의 네임스페이스 객체에 대한 프로미스(Promise) 객체를 반환한다.
- 이 프로미스 객체는 모듈 자체와 모든 모듈 의존성을 가져온 후, 인스턴스화하고 평가한 뒤에 만들어진다
- 동적 가져오기는 await와 함께 사용할 수 있다.
- 사용자 상호작용에 반응하거나 화면에 보이면 실행하기 등 자주 사용되는 패턴
은 동적 가져오기를 통해 바닐라 자바스크립트에서도 쉽게 구현할 수 있다

### 5.6.1 사용자 상호작용에 따라 가져오기

- 일부 기능은 사용자가 상호작용할 때만 필요할 수도 있다. (채팅 창, 다이얼로그, 비디오 등)

### 5.6.2 화면에 보이면 가져오기

- 많은 컴포넌트는 처음에 숨겨져 있다가 사용자가 아래로 스크롤하면 나타나도록 만들어지곤한다.
- 그러나 사용자가 항상 아래로만 스크롤하는 것은 아니기에 모듈을 `지연 로딩`으로 구현하면 좋다.
- IntersectionObserver API를 사용하면 컴포넌트가 화면에 보이는지 감지할 수 있고, 이에 따라 모듈을 동적으로 로드할 수도 있다.

## 5.8 모듈을 사용하면 생기는 이점

- **한 번만 실행된다 :** 기존 스크립트는 DOM에 추가될 때마다 실행되는 반면에 모듈 스크립트는 한 번만 실행된다.
- **자동으로 지연 로드된다**
- **유지보수와 재사용이 쉽다**
- **네임스페이스를 제공한다.**
- **사용하지 않는 코드를 제거한다 :** 모듈을 통해 코드를 가져오게 되면 웹팩이나 롤업 같은 번들러를 사용해 사용하지 않는 모듈을 자동으로 제거할 수 있다. 이처럼 번들에 추가하기 전에 사용하지 않는 코드를 제거하는 것을 `트리쉐이킹`이라고 한다.

## 5.9 생성자, 게터, 세터를 가진 클래스

- ES2015+에서는 모듈뿐만 아니라 생성자와 내부를 숨기는 기능을 가진 클래스가 추가되었다.
- 자바스크립트의 클래스는 프로토타입을 기반으로 하고 있으며, 사용하기 전에 미리 정의해야만 한다.
- extends 키워드를 통해 클래스를 상속받을 수도 있다.
- 모듈과 클래스의 차이점은 모듈은 가져오기와 내보내기를 통해, 클래스는 class 키워드를 통해 정의할 수 있다는 점이다.
- 또한 자바스크립트의 클래스는 부모 클래스의 생성자를 실행할 수 있는 super 키워드도 지원한다.
- 이는 자기 상속 패턴을 사용할 때 유용하다.
- super를 통해 부모 클래스의 메서드를 실행할 수도 있다.
- 클래스 멤버는 기본적으로 공개 상태이며, #(해시)를 앞에 붙여 비공개 멤
버로 만들 수 있다.
- 자바스크립트 클래스는 static 키워드를 통해 정적 메서드와 프로퍼티를 정의할 수 있다.
- 정적 멤버는 클래스를 초기화하지 않고도 사용할 수 있다.
- 주로 어떠한 설정이나 캐시 데이터를 보관하기 위해 사용된다.

## 5.10 자바스크립트 프레임워크와 클래스

- 리액트와 같은 최신 자바스크립트 라이브러리와 프레임워크는 클래스의 대체
제를 도입해 왔다.
- 대표적으로 **리액트 Hooks**는 클래스를 사용하지 않고도 리액트의 상
태와 라이프사이클을 다룰 수 있도록 만들어졌다.
- 리액트 Hooks가 도입되기 전에는 상태와 라이프사이클을 다루기 위해 어쩔 수 없이 함수 컴포넌트 대신 클래스 컴포넌트를 사용해야만 했다.
- 클래스 컴포넌트를 다루는 건 까다로운 작업일뿐더러 클래스에 대한 지식도 가지고 있어야 해서 작업은 매우 어려웠다.

# 6장. 디자인 패턴의 유형

## 6.1 배경

- 디자인 패턴은 공통 설계 구조의 핵심 요소를 이름 짓고 추상화하여 재사용할 수 있는 객체 지향 설계를 만드는 데 유용한 역할을 한다.
- 또한 유용한 클래스와 인스턴스를 제공하여 각각의 역할과 협업, 책임의 분배를 실현한다.
- 모든 디자인 패턴은 특정 객체 지향 설계의 문제나 이슈에 초점을 맞춘다.
- 또한 어디에 적용될 수 있는지, 다른 설계 조건에도 부합하는지, 사용함으로써 얻는 장단점과 결과를 설명한다.
- 결국에는 구현이 중요하기에 구현을 위한 예시 코드도 제공한다.
- 디자인 패턴은 어떤 문제를 해결하느냐에 따라 다음 `생성 패턴`, `구조 패턴`, `행위 패턴` 유형으로 분류된다.

## 6.2 생성 패턴

- 생성 패턴은 주어진 상황에 적합한 객체를 생성하는 방법에 중점을 둔다.
- 기본적인 객체 생성 방식은 프로젝트의 복잡성을 증가시킬 수도 있기에, 생성 패턴은 이 과정을 제어하여 문제를 해결하는 것을 목표로 한다.
- 생성자, 팬토리, 추상, 프로토타입, 싱글톤, 빌더 패턴이 생성 패턴에 속한다.

## 6.3 구조 패턴

- 구조 패턴은 객체의 구성과 각 객체 간의 관계를 인식하는 방법에 중점을 둔다.
- 그리고 시스템의 어느 한 부분이 변경되더라도 다른 부분에는 영향이 가지 않도록 도와주며, 설계 목적에 맞지 않는 부분을 개선하는 데에도 도움이 된다.
- 데코레이터, 퍼사드, 플라이웨이트, 어댑터, 프록시 패턴이 구조 패턴에 속한다.

## 6.4 행위 패턴

- 행위 패턴은 시스템 내의 객체 간 커뮤니케이션을 개선하거나 간소화하는 방법
에 중점을 둔다.
- 그리고 객체 간의 공통적인 커뮤니케이션 패턴을 감지하고 책임을 분배함
으로써 커뮤니케이션의 유연성을 높이고, 객체의 행위를 추상화한다.
- 이터레이터, 중재자, 관찰자, 방문자패턴이 행위 패턴에 속한다.

## 6.5 디자인 패턴의 분류

|  | **생성 패턴** | **객체 생성의 기반이 되는 개념** |
| --- | --- | --- |
| **클래스** | 팩토리 메서드 | 인터페이스를 기반으로 여러 파생 클래스를 생성 |
| **객체** | 추상 팩토리 | 구체적인 내부 구현 없이 여러 클래스가 상속받아 사용하는 인스턴스를 생성 |
|  | 빌더 | 객체를 생성하는 부분과 내부 구현을 분리하여 항상 같은 객체를 생성 |
|  | 프로토타입 | 복사 또는 복제에 사용되는 초기화된 인스턴스 |
|  | 싱글톤 | 전역에서 접근 가능한 하나만의 인스턴스를 가진 클래스 |

<br />

|  | **구조 패턴** | **객체 구조의 기반이 되는 개념** |
| --- | --- | --- |
| **클래스** | 어뎁터 | 호환되지 않는 인터페이스가 상호작용하도록 클래스를 매치 |
| **객체** | 브릿지 | 객체의 인터페이스와 구현을 분리하여 독립적으로 구성 |
|  | 컴포지트 | 단순히 합친 상태 이상의 효율을 내는 간단하면서 복합적인 구조 |
|  | 데코레이터 | 객체에 새로운 프로세스를 동적으로 추가 |
|  | 퍼사드 | 전체 시스템의 복잡한 부분을 숨기는 단일 클래스 |
|  | 플라이웨이트 | 여러 객체에 공통 상태를 공유하는 세분화된 인스턴스 |
|  | 프록시 | 실제 객체를 대신하는 대체 객체 |

<br />

|  | **행위 패턴** | **객체 상호작용의 기반이 되는 개념** |
| --- | --- | --- |
| **클래스** | 인터프리터 | 언어의 목적과 문법에 일치하는 언어 요소를 포함시키는 방법 |
|  | 템플릿 메서드 | 상위 클래스에서 기본 구조를 생성한 다음 하위 클래스에서 구체적으로 정의 |
| **객체** | 책임 연쇄 | 요청을 처리할 수 있는 객체를 찾기 위해 체인 간에 요청을 전달 |
|  | 커맨드 | 호출 부분과 실행 부분을 나누는 방법 |
|  | 이터레이터 | 내부 구조를 모른 채 요소에 순차적으로 접근 |
|  | 중재자 | 클래스가 서로를 직접적으로 참조하지 않도록 중간에 간소화된 커뮤니케이션을 정의 |
|  | 메멘토 | 나중에 복구할 수 있도록 객체의 내부 상태를 저장 |
|  | 관찰자 | 클래스 간의 일관성을 보장하기 위해 여러 클래스에 변경사항을 알리는 방법 |
|  | 상태 | 상태가 변경되면 객체의 행위도 변경 |
|  | 전략 | 클래스 내부에 알고리즘 구현을 캡슐화하여 상황에 따른 선택과 구현을 분리 |
|  | 방문자 | 클래스를 변경하지 않고도 새로운 작업을 추가 |

# 7장. 자바스크립트 디자인 패턴

## 7.2 생성자 패턴

- 생성자는 객체가 새로 만들어진 뒤 초기화하는 데에 사용되는 특별한 메서드이다.
- ES2015 버전 이후로 생성자를 가진 클래스를 만들 수 있게 되었다.
- 이로써 기본으로 제공되는 생성자를 통해 클래스의 인스턴스 객체를 생성할 수 있다.

### 7.2.2 생성자의 기본 특징

- 도입된 자바스크립트의 클래스는 객체 템플릿을 정의하고 캡슐화 및 상속을 구현할 수 있게 했다.
- 클래스는 새 객체를 초기화하는 constructorQ라는 이름의 메서드를 가지고 있어야 한다.
- 또한 new 키워드는 생성자를 호출할 수 있으며, 생성자 내부에서 사용된
this 키워드는 새로 생성된 해당 객체를 가리킨다.
- 몇 가지 문제가 있다.
- 하나는 상속이 어려워진다는 점이고, 다른 하나는 Car 생성자로 객체를 생성할 때마다 toString과 같은 함수를 새로 정의한다는 점이다.
- Car 유형의 인스턴스는 모두 동일한 함수를 공유해야 하므로 이 방법은 효과적이지 않다.

### 7.2.3 프로토타입을 가진 생성자

- 자바스크립트의 프로토타입 객체는 함수나 클래스 등 특정 객체의 모든 인스턴스 내에 공통 메서드를 쉽게 정의할 수 있게 한다.

> 근데 사실 이렇게 prototype에 직접 접근하는 것이 안 좋다고 배웠는데, 이 방법은 ‘공통 메서드를 쉽게 정의할 수 있게 한다’라는 측면에서는 맞지만, 권장하지 않는 방법인 것 같네요.
> 

## 7.3 모듈 패턴

- 모듈은 애플리케이션 아키텍처의 핵심 구성 요소이며 프로젝트를 구성하는 코드 단위를 체계적으로 분리 및 관리하는 데 효과적으로 활용된다.
- 초기 자바스크립트에서는 `객체 리터럴 표기법`, `모듈 패턴`, `AMD 모듈`, `CommonJS 모듈`과 같은 방법으로 모듈을 구현했다.

### 7.3.1 객체 리터럴

- 선언 시 new 연산자를 필요로 하지 않으며, 객체의 바깥에서 새로운 멤버를 추가하려면 다음과 같이 할당 연산자를 사용한다.
- 객체 리터럴을 사용하면 코드를 캡슐화하여 깔끔하고 체계적으로 정리할 수 있다.

### 7.3.2 모듈 패턴

- 클래스의 캡슐화를 위해 처음 고안되었다.
- 개발자들은 자바스크립트 모듈을 사용하여 객체, 함수, 클래스, 변수 등을 구성하여 다른 파일에 쉽게 내보내거나 가져올 수 있다.
- 이를 통해 서로 다른 모듈 간의 클래스 또는 함수명 충돌을 방지할 수 있다

**비공개**

- 모듈 패턴은 클로저를 활용해 ‘비공개’ 상태와 구성을 캡슐화한다.
- 이는 공개 및 비공개 메서드와 변수를 묶어 전역 스코프로의 유출을 방지하고 다른 개발자의 인터페이스와의 충돌을 예방한다.
- 모듈 패턴을 사용한다면 공개 API만을 노출하고 나머지는 클로저 내부에 비공개로 유지할 수 있다.
- 이를 통해 다른 애플리케이션이 사용해야 하는 부분만 노출하고, 핵심 작업은 보호하는 깔끔하고 체계적인 구조를 구축할 수 있다.
- 또한 모듈 패턴은 즉시 실행 함수 IIFE를 사용해 객체를 반환한다.
- ES2019(ES10)이전의 자바스크립트에서는 접근 제한자(#, 해시)를 지원하지 않아 엄밀히 말해 ‘비공개’라는 개념이 존재하지 않았다.
- 당시엔 변수를 공개 또는 비공개로 선언할 수 있는 방법이 없었기 때문에 함수 스코프를 이용해 비공개 개념을 구현했다.
- 모듈 패턴에서는 클로저를 통해 비공개를 구현하여 선언된 모듈 내부에서만 변수와 메서드를 사용할 수 있다.
- 하지만 반환되는 객체에 포함된 변수와 메서드는 공개되어 다른 곳에서도 사용할 수 있다.
- 반환된 객체에 포함된 변수를 비공개하려면 WeakMap을 사용할 수 있다.
- WeakMap은 객체만 키로 설정할 수 있으며 순회가 불가능하다.
- 모듈 내부의 객체에 접근하는 유일한 방법은 해당 객체의 참조를 통해서뿐이다.
- 모듈 외부에서는 모듈 내부에서 공개로 정의된 메서드를 통해서만 접근할 수 있다.
- 이러한 방식으로 모듈 패턴은 객체의 비공개를 보장한다.

네임스페이스, 공개 및 비공개 변수를 다루는 템플릿의 예제

```jsx
// A private counter variable
let myPrivateVar = 0;

// A private function that logs any arguments
const myPrivateMethod = foo => {
  console.log(foo);
};

const myNamespace = {
  // A public variable
  myPublicVar: 'foo',

  // A public function utilizing privates
  myPublicFunction(bar) {
    // Increment our private counter
    myPrivateVar++;

    // Call our private method using bar
    myPrivateMethod(bar);
  },
};

export default myNamespace;
```

**이점**

- 비공개 자유성 : 모듈 내부에서만 비공개 함수를 자유롭게 만들 수 있다. 다른 파일에서 접근할 수 없기에 완전한 비공개를 실현할 수 있다.
- 디버깅 용이성 : 대개 함수는 선언되고 이름이 정해지므로, 어떤 함수가 예외를 발생시켰는지 알아내려고 할 때 디버거에서 콜 스택을 찾기 쉬워진다.

### 7.3.3 모듈 패턴의 변형

**믹스인 가져오기 변형**

- 유틸 함수나 외부 라이브러리 같은 전역 스코프에 있는 요소를 모듈 내부의
고차 함수에 인자로 전달 할 수 있게 한다.
- 이를 통해 전역 스코프 요소를 가져와 맘대로 이름을 지정할 수 있다.

**장점**

- 초보 개발자가 이해하기 쉽다.
    - 모듈 사이의 의존성을 관리하고 전역 요소를 원하는 만큼 넘겨주어 코드의 유지보수를 용이하게 하고 독립적으로 만들어준다.
- 비공개를 지원한다.
    - 모듈 패턴에서는 export를 이용해 바깥으로 노출한 값들만 접
    근할 수 있다.
    - 바깥으로 노출하지 않은 값은 모듈 내부에 비공개로 유지된다.
    - 따라서 불필요한 전역 스코프 오염을 방지할 수 있다.
- 공개되면 안 되는 코드를 캡슐화할 수 있다.
    - 여러 의존성을 동시에 사용할 수 있고 이름의 충돌도 피할 수 있다.

**단점**

- 공개와 비공개 멤버를 서로 다르게 접근해야 한다.
- 나중에 추가한 메서드에서는 비공개 멤버에 접근할 수 없다.
    - 비공개 멤버는 쉽게 수정하기도 힘들기에 생각만큼 유연하게 사용할 수 없다.
- 자동화 단위 테스트에 해에서 비공개 멤버는 제외된다
- 핫 픽스가 필요한 오류를 고칠 때 복잡도를 높인다

### 7.3.4 WeakMap을 사용하는 최신 모듈 패턴

- WeakMap 객체는 약한 참조를 가진 키값의 쌍으로 이루어진 집합체이다.
- 키는 객체여야만 하나, 값으로는 뭐든지 넣을 수 있다.
- WeakMap 객체는 기본적으로 키가 약하게 유지되는 맵이다.
- 즉, 참조되지 않는 키는 가비지 컬렉션(GC)의 대상이 된다.

### 7.3.5 최신 라이브러리와 모듈

- 리액트 같은 자바스크립트 라이브러리를 만들 때 모듈 패턴을 사용할 수도 있다.

## 7.4 노출 모듈 패턴

- 하일만이 공개 변수나 메서드에 접근하기 위해 가져온 메인 객체의 이름을 반복해서 사용해야 한다는 점에 답답함을 느끼면서 생겨났다.
- 또한 객체 리터럴 표기법을 사용해 요소를 공개하는 것도 맘에 들지 않아 했다.
- 그 결과 모든 함수와 변수를 비공개 스코프에 정의하고, 공개하고 싶은 부분만 포인터를 통해 비공개 요소에 접근할 수 있게 해주는 익명 객체를 반환하는 패턴이 탄생했다.
- 노출 모듈 패턴을 사용하면 좀 더 구체적인 이름을 붙여 비공개 요소를 공개로 내보낼 수도 있다.

### 7.4.1 장점

- 코드의 일관성이 유지된다.
- 모듈의 가장 아래에 위치한 공개 객체를 더 알아보기 쉽게 바꾸어 가독성을 향상시킨다.

### 7.4.2 단점

- 노출 모듈 패턴의 단점은 비공개 함수를 참조하는 공개 함수를 수정할 수 없다는 것이다.
- 이는 비공개 함수가 비공개 구현을 참조하기 때문에 발생하며, 수정을 해도 함수가 변경될 뿐 참조된 구현이 변경되는 것이 아니기 때문이다.
- 비공개 변수를 참조하는 공개 객체 멤버 또한 수정이 불가능하다.
- 따라서 노출 모듈 패턴으로 만들어진 모듈은 기존 모듈 패턴보다도 취약할 수 있으므로 사용에 주의해야 한다.

## 7.5 싱글톤 패턴

- 싱글톤 패턴은 클래스의 인스턴스가 오직 하나만 존재하도록 제한하는 패턴이다.
- 이 패턴은 전역에서 접근 및 공유해야 하는 단 하나의 객체가 필요할 때 유용하다.
- 싱글톤 패턴을 구현하려면 이미 존재하는 인스턴스가 없어야 한다.
- 인스턴스가 이미 존재할 경우에는 해당 인스턴스의 참조를 반환한다.
- 싱글톤 패턴은 정적 클래스나 객체와는 다르게 초기화를 지연시킬 수 있다.
- 왜냐하면 초기화 시점에 필요한 특정 정보가 유효하지 않을 수도 있기 때문이다.
- 싱글톤의 특징은 인스턴스에 대한 전역 접근을 허용한다는 것이다.

싱글톤 패턴의 **적합성**

- 클래스의 인스턴스는 정확히 하나만 있어야 하며 눈에 잘 보이는 곳에 위치시켜 접근을 용이하게 해야 한다.
- 싱글톤의 인스턴스는 서브클래싱을 통해서만 확장할 수 있어야 하고, 코드의 수정 없이 확장된 인스턴스를 사용할 수 있어야 한다.

**싱글톤의 지연된 실행이 중요한 이유**

- 싱글톤과 정적 클래스(또는 객체) 사이의 차이점을 명확히 아는 것이 중요하다.
- 싱글톤을 정적 인스턴스로 구현했다 하더라도, 필요할 때까지는 리소스나 메모리를 소모하지 않도록 지연 생성될 수도 있다.

싱글톤과 정적 객체는 유용하지만 남용되어서는 안 된다.

- 시스템 전반에 걸쳐 접근할 수 있는 단 하나의 객체가 필요할 때 사용해
야 한다

**자바스크립트에서 싱글톤 클래스 사용 시 단점**

- 싱글톤임을 파악하는 것이 힘들다
    - 싱글톤 클래스를 일반 클래스로 착각하여 여러 객체를 인스턴스화하거나 부적절한 방법으로 수정할 수도 있다
- 테스트하기 힘들다
    - 숨겨진 의존성, 여러 인스턴스 생성의 어려움, 의존성 대체의 어려움 등 다양한 문제로 테스트하기에 생각보다 더 어려울 수 있다.
- 신중한 조정이 필요하다
    - 싱글톤의 일상적인 사용 사례로는 전역 범위에 걸쳐 필요한 데이터를 저장하는 것이 있다.
    - 예를 들어 한 번 설정되고 난 후에 여러 컴포넌트에서 사용할 수 있는 사용자 인증 정보나 쿠키 등이 있다.
    - 따라서 데이터가 유효하게 된 뒤에 사용할 수 있도록 올바른 실행 순서를 구현하는 일은 필수적이다.
    - 하지만 애플리케이션의 크기와 복잡성이 커짐에 따라 어려워질 수 있다.

### 7.5.1 리액트의 상태 관리

- 리액트를 통해 웹 개발을 한다면 싱글톤 대신 Context API나 리덕스 같은 전역 상태 관리 도구를 이용하여 개발할 수도 있다.
- 싱글톤과는 달리, 이러한 전역 상태 관리 도구는 변경 불가능한 읽기 전용 상태를 제공한다.

## 7.6 프로토타입 패턴

- 프로토타입 패턴을 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새
객체를 생성하는 패턴이라고 정의했다.
- 프로토타입 패턴은 프로토타입의 상속을 기반으로 한다.
- 이 패턴에서는 프로토타입 역할을 할 전용 객체를 생성하게 된다.
- 이렇게 만들어진 prototype 객체는 생성자를 통해 만들어진 객체의 설계도가 된다.
- 실제로는 프로토타입 상속과 클래스는 별개로 사용된다
- 프로토타입 상속은 클래스처럼 따로 정의되는 것이 아니라, 이미 존재하는 다른 객체를 복제하여 새로운 객체를 만들어낸다.
- 프로토타입 패턴의 장점은 다른 언어의 기능을 따라 하지 않고, 자바스크립트만이 가진 고유의 방식으로 작업할 수 있다는 것이다.
- 프로토타입 패턴은 상속을 구현하는 쉬운 방법일 뿐만 아니라 성능에서의 이점도 챙길 수 있다.
- 객체 내에 함수를 정의할 때 복사본이 아닌 참조로 생성되어 모든 자식 객체가 동일한 함수를 가리키게 할 수 있기 때문이다.
- 객체를 생성하기 위해 클래스와 생성자를 사용할 수 있습니다
- 이 방법이 코드의 가독성을 높이고 객체 지향 분석 설계 원칙을 따를 수 있게 해주지만, 클래스와 생성자도 결국 내부적으로는 함수와 프로토타입으로 컴파일된다.
- 즉 클래스와 생성자를 사용한다고 하더라도 여전히 프로토타입의 장점과 동시에 성능상 이점을 누리고 있는 것이다.
- 프로토타입의 상속은 Object.create를 필요로 한다.
- 다시 말해 Object.create는 프로토타입 객체를 생성하고 특정 속성을 추가할 수도 있다 (예 : Object.create(prototype,optionalDescriptorObjects))
- Object.Create는 다른 객체로부터 직접 상속할 수 있게 해주는 차등 상속과 같은 고급 개념을 쉽게 구현할 수 있게 해준다.
- 프로토타입 관계는 객체의 속성을 나열할 때 문제를 일으킬 수 있으므로, hasOwnProperty()로 속성을 체크하는 것을 추천한다.