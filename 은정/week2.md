# 5장. 최신 자바스크립트 문법과 기능

## 5.1 애플리케이션 분리의 중요성

- `모듈형` : 잘게 분리된 모듈로 구성되었음
- 모듈형을 통해 이루어진 느슨한 결합은 **의존성**을 낮추어 애플리케이션의 유지보수를 용이하게 만든다.

## 5.2 모듈 가져오기와 내보내기

- 모듈을 사용하면 각 기능에 맞는 독립적인 단위로 코드를 분리할 수 있다.
- 또한 모듈은 코드의 재사용성을 높여 다른 애플리케이션에도 같은 기능을 적용할 수 있게 한다.
- import문을 이용하면 내보내기된 모듈을 지역 변수로 가져올 수 있으며, 기존 변수명과의 충돌을 피하고자 이름을 바꿔서 가져올 수도 있다.
- export문을 이용하면 지역 모듈을 외부에서 읽을 수 있지만 수정할 수는 없도록 만들어준다.

## 5.5 정적으로 모듈 가져오기

- 정적 가져오기는 메인 코드를 실행하기 전에 먼저 모듈을 다운로드하고 실행해야 한다.
- 따라서 초기 페이지 로드 시 많은 코드를 미리 로드해야 하므로 성능에 문제가 생길 수도 있다.

## 5.6 동적으로 모듈 가져오기

- 모듈을 초기에 모두 미리 로드하기보다는 필요한 시점에만 로드하는 것이 더 이로울 때가 있다.
- 지연 로딩 모듈을 사용하면 필요한 시점에 로드할 수 있다
- 예를 들어 초기 로딩 시간을 줄일 수 있다.
- import(url)는 요청된 모듈의 네임스페이스 객체에 대한 프로미스(Promise) 객체를 반환한다.
- 이 프로미스 객체는 모듈 자체와 모든 모듈 의존성을 가져온 후, 인스턴스화하고 평가한 뒤에 만들어진다
- 동적 가져오기는 await와 함께 사용할 수 있다.
- 사용자 상호작용에 반응하거나 화면에 보이면 실행하기 등 자주 사용되는 패턴
은 동적 가져오기를 통해 바닐라 자바스크립트에서도 쉽게 구현할 수 있다

### 5.6.1 사용자 상호작용에 따라 가져오기

- 일부 기능은 사용자가 상호작용할 때만 필요할 수도 있다. (채팅 창, 다이얼로그, 비디오 등)

### 5.6.2 화면에 보이면 가져오기

- 많은 컴포넌트는 처음에 숨겨져 있다가 사용자가 아래로 스크롤하면 나타나도록 만들어지곤한다.
- 그러나 사용자가 항상 아래로만 스크롤하는 것은 아니기에 모듈을 `지연 로딩`으로 구현하면 좋다.
- IntersectionObserver API를 사용하면 컴포넌트가 화면에 보이는지 감지할 수 있고, 이에 따라 모듈을 동적으로 로드할 수도 있다.

## 5.8 모듈을 사용하면 생기는 이점

- **한 번만 실행된다 :** 기존 스크립트는 DOM에 추가될 때마다 실행되는 반면에 모듈 스크립트는 한 번만 실행된다.
- **자동으로 지연 로드된다**
- **유지보수와 재사용이 쉽다**
- **네임스페이스를 제공한다.**
- **사용하지 않는 코드를 제거한다 :** 모듈을 통해 코드를 가져오게 되면 웹팩이나 롤업 같은 번들러를 사용해 사용하지 않는 모듈을 자동으로 제거할 수 있다. 이처럼 번들에 추가하기 전에 사용하지 않는 코드를 제거하는 것을 `트리쉐이킹`이라고 한다.

## 5.9 생성자, 게터, 세터를 가진 클래스

- ES2015+에서는 모듈뿐만 아니라 생성자와 내부를 숨기는 기능을 가진 클래스가 추가되었다.
- 자바스크립트의 클래스는 프로토타입을 기반으로 하고 있으며, 사용하기 전에 미리 정의해야만 한다.
- extends 키워드를 통해 클래스를 상속받을 수도 있다.
- 모듈과 클래스의 차이점은 모듈은 가져오기와 내보내기를 통해, 클래스는 class 키워드를 통해 정의할 수 있다는 점이다.
- 또한 자바스크립트의 클래스는 부모 클래스의 생성자를 실행할 수 있는 super 키워드도 지원한다.
- 이는 자기 상속 패턴을 사용할 때 유용하다.
- super를 통해 부모 클래스의 메서드를 실행할 수도 있다.
- 클래스 멤버는 기본적으로 공개 상태이며, #(해시)를 앞에 붙여 비공개 멤
버로 만들 수 있다.
- 자바스크립트 클래스는 static 키워드를 통해 정적 메서드와 프로퍼티를 정의할 수 있다.
- 정적 멤버는 클래스를 초기화하지 않고도 사용할 수 있다.
- 주로 어떠한 설정이나 캐시 데이터를 보관하기 위해 사용된다.

## 5.10 자바스크립트 프레임워크와 클래스

- 리액트와 같은 최신 자바스크립트 라이브러리와 프레임워크는 클래스의 대체
제를 도입해 왔다.
- 대표적으로 **리액트 Hooks**는 클래스를 사용하지 않고도 리액트의 상
태와 라이프사이클을 다룰 수 있도록 만들어졌다.
- 리액트 Hooks가 도입되기 전에는 상태와 라이프사이클을 다루기 위해 어쩔 수 없이 함수 컴포넌트 대신 클래스 컴포넌트를 사용해야만 했다.
- 클래스 컴포넌트를 다루는 건 까다로운 작업일뿐더러 클래스에 대한 지식도 가지고 있어야 해서 작업은 매우 어려웠다.

# 6장. 디자인 패턴의 유형

## 6.1 배경

- 디자인 패턴은 공통 설계 구조의 핵심 요소를 이름 짓고 추상화하여 재사용할 수 있는 객체 지향 설계를 만드는 데 유용한 역할을 한다.
- 또한 유용한 클래스와 인스턴스를 제공하여 각각의 역할과 협업, 책임의 분배를 실현한다.
- 모든 디자인 패턴은 특정 객체 지향 설계의 문제나 이슈에 초점을 맞춘다.
- 또한 어디에 적용될 수 있는지, 다른 설계 조건에도 부합하는지, 사용함으로써 얻는 장단점과 결과를 설명한다.
- 결국에는 구현이 중요하기에 구현을 위한 예시 코드도 제공한다.
- 디자인 패턴은 어떤 문제를 해결하느냐에 따라 다음 `생성 패턴`, `구조 패턴`, `행위 패턴` 유형으로 분류된다.

## 6.2 생성 패턴

- 생성 패턴은 주어진 상황에 적합한 객체를 생성하는 방법에 중점을 둔다.
- 기본적인 객체 생성 방식은 프로젝트의 복잡성을 증가시킬 수도 있기에, 생성 패턴은 이 과정을 제어하여 문제를 해결하는 것을 목표로 한다.
- 생성자, 팬토리, 추상, 프로토타입, 싱글톤, 빌더 패턴이 생성 패턴에 속한다.

## 6.3 구조 패턴

- 구조 패턴은 객체의 구성과 각 객체 간의 관계를 인식하는 방법에 중점을 둔다.
- 그리고 시스템의 어느 한 부분이 변경되더라도 다른 부분에는 영향이 가지 않도록 도와주며, 설계 목적에 맞지 않는 부분을 개선하는 데에도 도움이 된다.
- 데코레이터, 퍼사드, 플라이웨이트, 어댑터, 프록시 패턴이 구조 패턴에 속한다.

## 6.4 행위 패턴

- 행위 패턴은 시스템 내의 객체 간 커뮤니케이션을 개선하거나 간소화하는 방법
에 중점을 둔다.
- 그리고 객체 간의 공통적인 커뮤니케이션 패턴을 감지하고 책임을 분배함
으로써 커뮤니케이션의 유연성을 높이고, 객체의 행위를 추상화한다.
- 이터레이터, 중재자, 관찰자, 방문자패턴이 행위 패턴에 속한다.

## 6.5 디자인 패턴의 분류

|  | **생성 패턴** | **객체 생성의 기반이 되는 개념** |
| --- | --- | --- |
| **클래스** | 팩토리 메서드 | 인터페이스를 기반으로 여러 파생 클래스를 생성 |
| **객체** | 추상 팩토리 | 구체적인 내부 구현 없이 여러 클래스가 상속받아 사용하는 인스턴스를 생성 |
|  | 빌더 | 객체를 생성하는 부분과 내부 구현을 분리하여 항상 같은 객체를 생성 |
|  | 프로토타입 | 복사 또는 복제에 사용되는 초기화된 인스턴스 |
|  | 싱글톤 | 전역에서 접근 가능한 하나만의 인스턴스를 가진 클래스 |

|  | **구조 패턴** | **객체 구조의 기반이 되는 개념** |
| --- | --- | --- |
| **클래스** | 어뎁터 | 호환되지 않는 인터페이스가 상호작용하도록 클래스를 매치 |
| **객체** | 브릿지 | 객체의 인터페이스와 구현을 분리하여 독립적으로 구성 |
|  | 컴포지트 | 단순히 합친 상태 이상의 효율을 내는 간단하면서 복합적인 구조 |
|  | 데코레이터 | 객체에 새로운 프로세스를 동적으로 추가 |
|  | 퍼사드 | 전체 시스템의 복잡한 부분을 숨기는 단일 클래스 |
|  | 플라이웨이트 | 여러 객체에 공통 상태를 공유하는 세분화된 인스턴스 |
|  | 프록시 | 실제 객체를 대신하는 대체 객체 |

|  | **행위 패턴** | **객체 상호작용의 기반이 되는 개념** |
| --- | --- | --- |
| **클래스** | 인터프리터 | 언어의 목적과 문법에 일치하는 언어 요소를 포함시키는 방법 |
|  | 템플릿 메서드 | 상위 클래스에서 기본 구조를 생성한 다음 하위 클래스에서 구체적으로 정의 |
| **객체** | 책임 연쇄 | 요청을 처리할 수 있는 객체를 찾기 위해 체인 간에 요청을 전달 |
|  | 커맨드 | 호출 부분과 실행 부분을 나누는 방법 |
|  | 이터레이터 | 내부 구조를 모른 채 요소에 순차적으로 접근 |
|  | 중재자 | 클래스가 서로를 직접적으로 참조하지 않도록 중간에 간소화된 커뮤니케이션을 정의 |
|  | 메멘토 | 나중에 복구할 수 있도록 객체의 내부 상태를 저장 |
|  | 관찰자 | 클래스 간의 일관성을 보장하기 위해 여러 클래스에 변경사항을 알리는 방법 |
|  | 상태 | 상태가 변경되면 객체의 행위도 변경 |
|  | 전략 | 클래스 내부에 알고리즘 구현을 캡슐화하여 상황에 따른 선택과 구현을 분리 |
|  | 방문자 | 클래스를 변경하지 않고도 人로운 작업을 추가 |