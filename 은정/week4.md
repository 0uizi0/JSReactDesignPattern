# 7장. 자바스크립트 디자인 패턴
## 행위 패턴
- 행위 패턴은 객체 간의 의사소통을 돕는 패턴으로, 시스템 내 서로 다른 객체 간의 의사소통 방식을 개선하고 간소화하는 것을 목적으로 한다.
- 자바스크립트의 행위 패턴들
  - 관찰자 패턴
  - 중재자 패턴
  - 커맨드 패턴

### 관찰자 패턴
- 관찰자 패턴은 한 객체가 변경될 때 다른 객체들에 변경되었음을 알릴 수 있게 해주는 패턴이다
- 변경된 객체는 누가 자신을 구독하는지 알 필요 없이 알림을 보낼 수 있다
- 한 객체(주체)를 관찰하는 여러 객체들(관찰자)이 존재하며, 주체의 상태가 변화하면 관찰자들에게 자동으로 알림을 보낸다
- 관찰자 패턴의 구성 요소들
  - **주체** : 관찰자 리스트를 관리하고, 추가와 삭제를 가능하게 한다
  - **관찰자** : 주체의 상태 변화 알림을 감지하는 update 인터페이스를 제공한다
  - **구체적 주체(ConcreteSubject)** : 상태 변화에 대한 알림을 모든 관찰자에게 전달하고, ConcreteObserver의 상태를 저장한다
  - **구체적관찰자(ConcreteObserver)** : ConcreteSubject의 참조를 저장하고, 관찰자의 update 인터페이스를 구현하여 주체의 상태 변화와 관찰자의 상태 변화가 일치할 수 있도록 한다

#### 관찰자 패턴과 발행/구독 패턴의 차이점
- 실제 자바스크립트 환경에서는 발행/구독 패턴이라는 변형된 형태의 구현이 더 널리 사용된다
- 관찰자 패턴에서는 이벤트 발생에 대해 알림 받기를 원하는 관찰자 객체가 이벤트를 발생시키는 주체 객체에 알림 대상으로 등록되어야 한다
- 반면 발행/구독 패턴에서는 이벤트 알림을 원하는 구독자와 이벤트를 발생시키는 발행자 사이에 **토픽/이벤트 채널**을 둔다
- 이러한 이벤트 시스템을 통해 애플리케이션에 특화된 이벤트를 정의할 수 있고, 구독자에게 필요한 값이 포함된 커스텀 인자를 전달할 수 있다
- 발행/구독 패턴의 핵심은 **발행자와 구독자를 각각 독립적으로 유지**한다는 것이다.
- 이러한 점에서 관찰자 패턴과 구별되는데, 발행/구독 패턴에서는 **적절한 이벤트 핸들러를 가지고 있는 구독자라면 누구나** 발행자가 전파하는 토픽의 알림을 받게 할 수 있다
- 발행/구독 패턴의 핵심은 **시스템의 구성 요소 간에 느슨한 결합을 도모한다**는 것이다. 객체(발행자)가 다른 객체(구독자)의 메서드를 직접 호출하는 대신, 구독자는 특정 작업이나 활동을 구독하고 해당 작업이나 활동이 발생했을 때 알림을 받게 된다

#### 관찰자 패턴과 발행/구독 패턴의 장점
- 각각의 요소들이 직접 연결되어 있는 곳을 파악하여, 주체와 관찰자의 관계로 대체할 수 있는 부분을 찾아낼 수 있도록 도움을 준다
- 이를 통해 애플리케이션을 더 작고 느슨하게 연결된 부분으로 나눌 수 있고, 결과적으로 코드의 관리와 재사용성을 높일 수 있다
- 관찰자 패턴을 사용하는 또 다른 이유는 클래스를 강하게 결합시키지 않으면서 관련 객체들 사이의 일관성을 유지해야 하는 상황에 있다
- 관찰자 패턴 또는 발행/구독 패턴을 사용하면 주체와 객체 사이에 동적인 관계가 형성된다. 이를 통해 애플리케이션의 여러 부분이 강하게 결합되어 있을 때 구현하기 까다로운 뛰어난 유연성을 쉽게 구현할 수 있다
> 관찰자 패턴과 발행/구독 패턴이 모든 문제에 대한 최고의 해결책은 아닐지라도, 이 패턴들은 시스템 구성 요소 간 결합도를 낮추는 훌륭한 도구이다

#### 관찰자 패턴과 발행/구독 패턴의 단점
- 발행자/구독 패턴에서는 발행자와 구독자의 연결을 분리함으로써, 애플리케이션의 특정 부분들이 기대하는 대로 동작하고 있다는 것을 보장하기 어려워질 수 있다
- 구독자들이 서로의 존재에 대해 전혀 알 수가 없고 발행자를 변경하는 데 드는 비용을 피할 수 없다
- 구독자와 발행자 사이의 관계가 동적으로 결정되기 때문에 어떤 구독자가 어떤 발행자에 의존하는지 추적하기 어려울 수 있다

#### 발행/구독 패턴과 자바스크립트 생태계
- 발행/구독 패턴은 자바스크립트 생태계와 매우 잘 어울리는데, 왜냐하면 ECMAScript의 구현체가 본질적으로 이벤트 기반이기 때문이다
- 브라우저 환경에서는 DOM을 스크립트를 위한 주요 상호작용 API로써 사용하므로 이벤트 기반의 구조임이 더욱 뚜렷하다
- 모듈 간 높은 결합도를 가진 애플리케이션은 코드 사이에 의존성이 증가하여 기능을 재사용하기 어렵게 만들 수 있다
- 같은 데이터 소스를 다루는 여러 요청을 나중에 하나하나 수정하는 대신에 처음부터 발행/구독 패턴을 사용하면 시간을 절약할 수 있었을 것이다
- 관찰자 패턴을 사용한다면 애플리케이션 전반에 걸쳐 발생하는 다양한 이벤트의 알림을 원하는 만큼 자세한 수준으로 분리할 수 있다
- 이런 기능은 다른 패턴에서는 구현하기 어려운 기능이다

#### 리액트 생태계에서의 관찰자 패턴
- RxJS는 관찰자 패턴을 사용하는 대표적인 라이브러리이다
- ReactiveX는 관찰자 패턴, 이터레이터 패턴 그리고 함수형 프로그래밍 등의 개념을 결합하여, 이벤트의 시퀀스를 관리하는 데에 이상적인 방법을 제공한다
- 관찰자 패턴은 애플리케이션의 설계에서 여러 요소들 간의 결합도를 낮추는 데에 유용한 패턴이다

### 중재자 패턴
- 중재자 패턴은 하나의 객체가 이벤트 발생 시 다른 여러 객체들에게 알림을 보낼 수 있는 디자인 패턴이다
- 이 패턴은 하나의 객체가 다른 객체에서 발생한 특정 유형의 이벤트에 대해 알림을 받을 수 있다는 점이다
- 반면에 관찰자 패턴은 하나의 객체가 다른 객체에서 발생하는 다수의 이벤트를 구독할 수 있도록 한다
- 관찰자 패턴에 대해 설명하는 부분에서 여러 개의 이벤트 소스를 하나의 객체로 보내는 방법을 '발행/구독' 또는 '이벤트 집합'이라고 한다
- 개발자들은 이러한 문제에 직면했을 때 중재자 패턴을 고려하는 경우가 많은데, 둘이 어떻게 다른지 알아보아야 한다
- 중재자는 행위 디자인 패턴이며, 시스템의 여러 부분이 통신할 수 있는 통합된 인터페이스를 제공한다
- 시스템의 구성 요소들 사이에 직접적인 관계가 너무 많은 것 같다면 중앙 통제 포인트를 두어서 모든 구성 요소들이 이를 통해 간접적으로 소통하도록 할 때가 된 것일 수도 있다
- 중재자 패턴은 구성 요소 간의 관계를 관리함으로써 직접 참조를 없애고 느슨한 결합을 가능하게 한다. 이는 시스템 결합도를 낮추고 구성 요소의 재사용성을 높여준다
- 다른 사례로는 DOM의 이벤트 버블링과 이벤트 위임을 들 수 있다
  - 시스템의 모든 이벤트 등록이 일어날 개별 DOM 노드 대신 최상위 Document 객체를 대상으로 했을 경우 Document 객체는 사실상 중재자 역할을 하게 되는 것이다
  - 다시 말해 개별 노드 대신 Document 객체에 이벤트를 연결하고, 이벤트가 발생하면 Document 객체가 개별 노드에 알려주는 방식이다
- 중재자 패턴과 이벤트 집합 패턴의 구현이 비슷할 수 있어서 겉으로 보기엔 서로 호환이 가능해 보일 수 있지만, 두 패턴의 의미와 의도는 매우 다르다
- 중재자는 여러 객체 간의 상호작용(로직과 행동)을 조율하는 객체이다. 중재자는 다른 객체들의 행동과 입력에 따라 언제 어느 객체를 호출할지 결정한다

### 중재자 패턴과 이벤트 집합 패턴
- **유사점 1. 이벤트**
  - 이벤트 집합 패턴이 이벤트를 다루는 패턴이라는 것은 그 이름에서 알 수 있듯 명백하다
  - 반면에 중재자 패턴은 최신 자바스크립트 웹 애플리케이션 프레임워크에서 구현을 단순화하기 위해 이벤트를 활용할 뿐이다
  - 따라서 중재자 패턴이 반드시 이벤트를 다룰 필요는 없다. 대신 중재자 객체에 대한 참조를 하위 객체에 전달하거나 그 외의 수단을 사용하는 등 콜백 메서드를 통해 구현할 수 있다
  - 그러므로 두 패턴이 왜 이벤트를 사용하는지에 대해 차이점이 존재한다
  - 이벤트 집합 패턴은 그 자체로 이벤트를 처리하기 위한 목적으로 설계된 패턴이다.
  - 하지만 중재자 패턴은 단순히 편리하기 때문에 이벤트를 활용할 뿐이다
- **유사점 2. 서드 파티 객체**
  - 설계상, 이벤트 집합 패턴과 중재자 패턴 모두 상호작용을 간소화하기 위해 서드 파티 객체를 사용한다
  - 이벤트 집합 패턴 자체는 이벤트 발행자와 구독자에 대해 서드 파티 객체이며, 모든 이벤트가 통과하는 중앙 허브의 역할을 한다
  - 중재자 패턴 또한 다른 객체에 대한 서드 파티 객체이다
  - 그렇다면 차이점이 무엇일까? 왜 이벤트 집합 패턴과 중재자 패턴을 구분할까? 이에 대한 답은 애플리케이션 로직과 워크플로가 어디에 구현되어 있는지에 달려있다
  - 이벤트 집합 패턴에서 서드 파티 객체는 알 수 없는 수의 소스에서 알 수 없는 수의 핸들러로 이벤트가 연결되도록 지원하는 역할만 한다
  - 실행되어야 하는 모든 워크플로와 비즈니스 로직은 이벤트를 발생시키는 객체(소스)와 처리하는 객체(핸들러)에 직접 구현된다
  - 중재자 패턴에서 비즈니스 로직과 워크플로는 중재자 내부에 집중된다
  - 중재자는 자신이 보유한 정보를 바탕으로 각 객체의 메서드 호출 시점과 속성 업데이트의 필요성을 판단한다
  - 이를 통해 워크플로와 프로세스를 캡슐화하고 여러 객체 사이를 조율해 시스템이 원하는 대로 동작하도록 한다
  - 이벤트 집합 패턴은 ‘발행 후 망각’ 방식의 소통 모델을 사용한다
  - 이벤트를 발생시키는 객체는 구독자의 존재 여부에 상관없이 이벤트를 발행한 후 처리를 위임한다
  - 한편, 중재자 패턴은 이벤트를 의사결정에 활용할 수는 있지만 ‘발행 후 망각’과는 거리가 멀다
  - 중재자는 미리 설정해 둔 특정 입력 또는 활동에 주목함으로써 역할이 분명한 참여자(객체) 사이의 행동을 조율하고 촉진한다

#### 이벤트 집합 패턴의 활용
- 이벤트 집합 패턴은 직접적인 구독 관계가 많아질 경우 또는 전혀 관련 없는 객체들 간의 소통이 필요할 때 사용된다
- 예를 들어 부모 뷰와 자식 뷰같이 두 객체 간의 직접적인 관계가 존재하는 경우, 이벤트 집합 패턴을 사용하면 이점이 있을 수 있다
- 이벤트 집합 패턴은 간접적인 관계를 가진 객체 간의 소통이 필요한 상황에서도 유용하게 활용된다
- 최신 애플리케이션에서는 직접적인 연관성이 없는 다수의 뷰 객체들이 상호작용하는 것이 일반적이다
- 하지만 메뉴가 세부 내용을 표시하는 뷰와 강하게 결합될 경우 코드의 유지보수가 어려워지므로 바람직하지 않다

#### 중재자 패턴의 활용
- 중재자 패턴은 두 개 이상의 객체가 간접적인 관계를 가지고 있고 비즈니스 로직이나 워크플로에 따라 상호작용 및 조정이 필요한 경우에 유용하다
- 중재자 패턴을 도입함으로써 개별 뷰 간의 직접 참조로 인한 강한 결합을 방지하고, 비즈니스 로직에 따른 워크플로를 명확하고 효율적으로 모델링할 수 있다
- 중재자 패턴은 구현 세부사항에서 워크플로를 추출함으로써 보다 상위 레벨에서 워크플로를 자연스럽게 추상화한다
- 이를 통해 개발자는 워크플로 파악을 위해 개별 뷰를 분석할 필요없이 전체적인 흐름을 더욱 빠르게 파악할 수 있다

#### 중재자 패턴과 퍼사드 패턴
- 중재자 패턴은 모듈이 명시적으로 중재자를 참조함으로써 모듈 간의 상호작용을 중앙집중화한다
- 이는 본질적으로 다방향성을 지닌다
- 반면에 퍼사드 패턴은 모듈 또는 시스템에 직관적인 인터페이스를 제공하지만 추가 기능을 구현하지는 않는다
- 시스템 내 다른 모듈은 퍼사드의 개념을 직접적으로 인지하지 못하므로 단방향성을 지닌다

### 커맨드 패턴
- 커맨드 패턴은 메서드 호출, 요청 또는 작업을 단일 객체로 캡슐화하여 추후에 실행할 수 있도록 해준다
- 이를 통해 실행 시점을 유연하게 조정하고 호출을 매개변수화할 수도 있다
- 또한 커맨드 패턴은 명령을 실행하는 객체와 명령을 호출하는 객체 간의 결합을 느슨하게 하여 구체적인 클래스(객체)의 변경에 대한 유연성을 향상시킨다
- 구체 클래스(또는 구상 클래스)는 클래스 기반 프로그래밍 언어에서 중요한 개념으로, 추상 클래스와도 연관이 있다
- 추상 클래스는 인터페이스를 제공하지만 모든 멤버 함수의 구현을 제공하지는 않는다
- 추상 클래스는 상속을 통해 구체화되는 기초 클래스의 역할을 한다
- 커맨드 패턴의 기본 원칙은 명령을 내리는 객체와 명령을 실행하는 객체의 책임을 분리한다는 것이다
- 커맨드 패턴은 이러한 책임을 다른 객체에 위임함으로써 역할 분리를 실현한다
- 구현 측면에서 단순 커맨드 객체는 ‘실행할 동작’과 ‘해당 동작을 호출할 객체’를 연결한다
- 커맨드 패턴의 요 장점은 인터페이스가 동일한 모든 커맨드 객체를 쉽게 교체할 수 있다는 점이다

<br/>

# 8장. 자바스크립트 MV* 패턴

- 애플리케이션 설계에는 객체의 설계와 애플리케이션 아키텍처라는 두 가지 중요한 측면이 있다
- 이번 장에서는 3가지 기본 아키텍처 패턴인 MVC(모델-뷰-컨트롤러), MVP(모델-뷰-프리젠터), MVVM(모델-뷰-뷰모델)을 살펴볼 것이다
- 이 패턴들은 과거에 데스크톱 애플리케이션과 서버 사이드 애플리케이션의 구조화에 주로 사용되어왔지만, 현재는 자바스크립트 환경에도 적용되어 사용되고 있다

## MVC 패턴
- MVC 패턴은 애플리케이션의 구조를 개선하기 위해 관심사의 분리를 활용하는 아키텍처 디자인 패턴이다
- 비즈니스 데이터 (모델)과 UI (뷰)를 분리하고, 세 번째 구성 요소(컨트롤러)가 로직과 사용자 입력을 관리하는 구조이다

### MVC를 사용하는 이유는?
MVC에서의 관심사 분리는 애플리케이션의 기능을 더 간단한 모듈로 나눌 수 있도록 해주며, 다음과 같은 이점을 제공한다
- **전반적인 유지보수의 단순화**: 애플리케이션을 업데이트해야 할 때, 변경사항이 데이터 중심인지 (모델과 컨트롤러의 변경) 아니면 단순히 시각적인 변경인지 (뷰의 변경) 명확하게 구분할 수 있다
- **모델과 뷰의 분리**: 비즈니스 로직에 대한 단위 테스트의 작성이 훨씬 간편해진다
- 애플리케이션 전반에서 하위 수준의 모델 및 컨트롤러 코드 중복이 제거된다
- 애플리케이션의 규모와 역할의 분리 정도에 따라, 모듈화를 통해 코어 로작을 담당하는 개발자와 UI 작업을 담당하는 개발자가 동시에 작업할 수 있다

### MVC의 또 다른 관점(with GoF)
- 모델은 애플리케이션의 데이터를 표현하고, 뷰는 사용자에게 화면에 표시되는 것을 나타낸다
- MVC는 이러한 핵심 커뮤니케이션의 일부에 관찰자 패턴을 사용한다(놀랍게도 많은 MVC 관련 글에서 다루지 않는 부분이다)
- 모델이 변경되면 변경사항에 대한 알림을 관찰자 (뷰)에게 보내는데, 이게 바로 MVC에서 아마 가장 중요한 관계일 것이다
- 또한, 이 관계에서 사용된 관찰자 패턴의 특성으로 인해 여러 뷰가 동일한 모델에 연결되는 것도 가능하다

## MVP 패턴
- MVP 패턴은 프레젠테이션 로직의 개선에 초점을 맞춘 MVC 디자인 패턴의 파생이다
- MVC와 MVP 모두 여러 구성 요소 간의 관심사 분리를 목표로 하지만, 몇 가지 근본적인 차이점이 있다

### 모델, 뷰, 프리젠터
- MVP에서 P는 프리젠터를 의미한다
- 프리젠터는 뷰에 대한 UI 비즈니스 로직을 담당하는 구성 요소이다
- MVC와 달리, 뷰에서의 이벤트 호출은 프리젠터로 위임된다
- 프리젠터는 뷰와 분리되어 있으며, 인터페이스를 통해 뷰와 통신한다
- 이 방식은 단위 테스트에서 뷰를 모킹할 수 있는 등의 많은 장점을 제공한다
- MVC와 MVP는 C (컨트롤러)와 P (프리젠터)의 역할이 다르기 때문에 구분된다
- MVP에서 P는 모델을 관찰하고 모델이 변경될 때 뷰를 업데이트한다
- P는 모델과 뷰를 효과적으로 연결하는데, 이건 원래 MVC에서 컨트롤러가 담당하던 역할이다
- 모델이 이벤트를 발생시킬 수도 있지만, 이벤트를 구독하여 뷰를 업데이트할 수 있도록 하는 것이 프리젠터의 역할이다
- 이러한 수동형 아키텍처에서는 직접적인 데이터 바인딩의 개념이 없다
- 대신 뷰는 프리젠터가 데이터를 설정하는 데 사용할 수 있는 세터를 제공한다
- MVC에서 MVP로의 변화는 애플리케이션의 테스트 용이성을 높이고 뷰와 모델 간의 분리를 더욱 명확하게 해준다는 장점이 있다
- 그러나 MVP 패턴에는 데이터 바인딩이 지원되지 않기 때문에, 작업을 별도로 처리해야 하는 비용이 발생할 수 있다

### MVP와 MVC
- MVP는 일반적으로 프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 애플리케이션에서 사용된다
- 뷰가 매우 복잡하고 사용자와의 상호작용이 많은 애플리케이션에서는 MVC가 적합하지 않을 수 있다
- 이런 문제를 MVC로 해결하려면 여러 컨트롤러에 크게 의존해야 할 수 있기 때문이다
- MVP에서는 이 모든 복잡한 로직을 프리젠터 안에 캡슐화할 수 있어 유지보수가 훨씬 간단해진다
- MVP의 뷰는 인터페이스를 통해 정의되고, 인터페이스가 시스템과 뷰(프리젠터 제외) 간의 유일한 접점이므로, 이 패턴을 사용하면 개발자는 디자이너가 애플리케이션의 레이아웃과 그래픽을 완성하기를 기다리지 않고도 프레젠테이션 로직을 작성할 수 있다
- MVP는 구현 방식에 따라 MVC보다 단위 테스트가 더 쉬울 수 있다
- 프리젠터를 UI의 완전한 모킹으로 사용하여 다른 구성 요소와 독립적으로 단위 테스트를 할 수 있기 때문이다
- MVC와 MVP 간의 차이점이 대부분 의미론적인 수준이므로, MVC에 존재하는 근본적인 문제점들은 MVP에도 동일하게 존재할 가능성이 크다
- 하지만 모델, 뷰, 컨트롤러 (또는 프리젠터)로 관심사를 명확히 분리하기만 한다면, 어떤 패턴을 선택하든지 간에 대부분 동일한 장점을 얻을 수 있을 것이다

## MVVM 패턴
- MVC와 MVP를 기반으로 하는 아키텍처 패턴으로, 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리한다
- 많은 MVVM의 구현 방식은 선언적 데이터 바인딩을 활용하여 뷰에 대한 작업을 다른 계층과 분리할 수 있도록 한다
- 이러한 기법을 통해 동일한 코드베이스 내에서 UI 작업과 개발 작업을 거의 동시에 진행할 수 있다
- UI 개발자는 문서 마크업 (HTML) 내에서 뷰모델에 대한 바인딩을 작성하는 한편, 애플리케이션 로직을 담당하는 개발자들은 모델과 뷰모델을 관리하게 된다
- MVVM을 구성하는 세 가지 요소
  - **모델**: 도메인에 관련된 정보를 전달한다
  - **뷰**: 사용자 인터페이스(UI)이다
  - **뷰모델**: 모델과 뷰 사이의 인터페이스 역할을 한다
#### 뷰와 뷰모델
- 뷰와 뷰모델은 데이터 바인딩과 이벤트를 통해 소통한다
- 뷰모델은 모델의 속성을 단순히 제공하는 것뿐만 아니라, 데이터 유효성 검사 같은 다른 메서드와 기능에 대한 접근도 허용한다
- 뷰는 자체 UI 이벤트를 처리하고, 필요에 따라 뷰모델에 연결한다
- 모델과 뷰모델의 속성은 양방향 데이터 바인딩을 통해 동기화되고 업데이트된다
- 또한, 데이터 트리거를 사용하면 모델 속성의 상태 변화에 추가적으로 대응할 수도 있다
#### 뷰모델과 모델
- 뷰모델은 데이터 바인딩을 위해 모델 또는 모델의 속성을 가져올 수 있고, 뷰에 제공되는 속성을 가져오거나 조작하기 위한 인터페이스를 포함할 수 있다
#### MVVM의 장점
- MVVM은 UI와 이를 구동하게 해주는 요소를 동시에 개발할 수 있도록 한다
- MVVM은 뷰를 추상화함으로써 뷰의 뒤에 작성되는 비즈니스 로직(또는 연결 코드)의 양을 줄여준다
- 뷰모델은 이벤트 중심 코드에 비해 단위 테스트가 더 쉽다
- 뷰모델은 (뷰보다는 모델에 가까우므로) UI 자동화나 상호작용에 대한 고려 없이도 테스트가 가능하다
#### MVVM의 단점
- 단순한 UI의 경우, MVVM은 과도한 구현이 될 수 있다
- 데이터 바인딩은 선언적이고 사용하기 편리할 수 있지만 단순히 중단점 breakpoints을 설정하는 명령형 코드에 비해 디버깅이 더 어려울 수 있다
- 복잡한 애플리케이션에서는, 데이터 바인딩이 상당한 관리 부담을 만들어 낼 수 있다. 또한 바인딩 코드가 바인딩 대상 객체보다 더 무거운 상황도 피하고 싶어한다
- 대규모 애플리케이션에서는 필요한 일반화를 제공하기 위해 뷰모델을 미리 설계하는 것이 어려울 수 있다

### MVC vs MVP vs MVVM
- MVP와 MVVM은 모두 MVC에서 파생된 패턴이다
- MVC와 이 파생 패턴들 사이의 핵심 차이점은 각 계층이 다른 계층에 대해 갖는 의존성과, 서로 얼마나 강하게 연결되어 있는지에 있다
- MVC에서는 뷰가 아키텍처의 최상단에 위치하고 그 옆에는 컨트롤러가 있다
- 모델은 컨트롤러 아래에 있기 때문에, 뷰는 컨트롤러에 대해 알고 있고, 컨트롤러는 모델에 대해 알고 있다
- 이 구조에서 뷰는 모델에 직접 접근할 수 있다
- 하지만 전체 모델을 뷰에 노출하는 것은 애플리케이션의 복잡도에 따라 보안 및 성능에 문제를 일으킬 수 있다
- MVVM은 이러한 문제를 피하기 위한 패턴이다
- MVP에서는 컨트롤러의 역할이 프리젠터로 대체된다
- 프리젠터는 뷰와 동일한 계층에 존재하며, 뷰와 모델 양쪽에서 발생하는 이벤트를 수신하고 이들 간의 동작을 조정한다
- MVVM과는 달리, 뷰와 뷰모델을 바인딩하는 메커니즘이 없기 때문에, 각 뷰는 프리젠터가 뷰와 상호작용할 수 있도록 인터페이스를 구현한다
- 결과적으로, MVVM을 사용하면 상태와 로직 정보를 포함할 수 있는 뷰와 관련된 모델 일부를 생성할 수 있다
- 이를 통해 전체 모델을 뷰에 노출하는 것을 피할 수 있다
- MVP의 프리젠터와 달리, 뷰모델은 뷰를 참조할 필요가 없다
- 뷰는 뷰모델의 속성을 바인딩하여 모델에 포함된 데이터를 뷰에 표현할 수 있다
- 앞서 언급했듯이 뷰가 추상화되기 때문에 뷰에 필요한 로직의 양이 줄어든다
- 뷰와뷰모델 분리의 단점은 둘 사이에 일정 수준의 변환이 필요해 성능에 영향을 줄 수 있다는 점이다

## 최신 MV* 패턴
- 기술적으로 리액트나 Vue.js와 같은 최신 라이브러리와 프레임워크는 애플리케이션의 뷰 또는 프레젠테이션 계층을 구성한다
- 대부분의 경우에 이 프레임워크들은 모델 구현 방식과 애플리케이션의 상태 관리에 대해 유연하다 
- Vue.js는 공식적으로 뷰모델을 사용하는 MVVM 패턴이라고 주장한다
- 리액트에서는 MV* 패턴에 대한 몇 가지 추가적인 고려사항이 있다

### MV* 패턴과 리액트
- 분명히 말하자면, 리액트는 MVC 프레임워크가 아니다
- 리액트는 UI 구축을 위한 자바스크립트 라이브러리이며, 주로 SPA 개발에 사용된다
- 리액트는 백엔드에서 전통적으로 구현되고, 사용되는 MVC 패턴과 잘 맞지 않기 때문에 MVC로 분류되지 않는다
- 리액트는 뷰 계층을 원하는대로 구성하게 해주는 렌더링 라이브러리이다
- 기존 MVC와 같이 중앙 제어 역할을 하는 컨트롤러, 혹은 라우터 기능이 포함되어 있지 않다
- 리액트를 MVC 디자인 패턴에서 사용하지 않는 이유는 리액트에서는 서버가 브라우저에 '뷰'를 직접 제공하지 않고, '데이터'를 제공하기 때문이다
- 리액트는 이 데이터를 브라우저에서 구문 분석하여 실제 뷰를 생성한다
- 이러한 관점에서, 리액트를 MVC 패턴의 뷰(V)라고 할 수는 있지만, 전통적인 의미에서의 MVC 프레임워크는 아니다
- 다른 관점에서 보면 리액트는 MVC를 기술에 따라 수평적으로 나누는 대신, 관심사에 따라 수직적으로 나눈다
- 리액트의 컴포넌트는 상태 (모델), 렌더링(뷰), 제어 흐름 로직(소규모의 지역화된 컨트롤러)를 담고 있는 작은 수직 분할형 MVC로 시작했다고 볼 수 있다
- 최근에는 많은 컴포넌트 로직이 Hooks로 구성됨에 따라, 컴포넌트를 뷰로, Hooks를 컨트롤러로 볼 수 있다
- '모델=비동기 데이터,뷰=컴포넌트,컨트롤러= Hook'으로 이해하는 것도 도움이 될 수 있지만, 단순히 개념 파악을 위한 비유일 뿐 엄밀한 뜻은 아니다

### MV* 패턴과 Next
- 리액트와 마찬가지로 Next.js도 MVC 프레임워크는 아니지만, 서버 사이드 렌더링 (SSR) 또는 정적 사이트 생성(SSG)을 사용하는 경우 MVC와 유사한 패턴으로 동작할 수 있다
- Next.js가 백엔드 역할을 수행하여 데이터베이스와 상호작용하고 뷰를 사전 렌더링하면, 이후부터는 리액트의 반응형 기능을 통해 뷰를 동적으로 업데이트함으로써 전통적인 MVC 형태로 동작한다
