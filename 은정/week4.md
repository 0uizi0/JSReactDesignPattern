# 7장. 자바스크립트 디자인 패턴
## 행위 패턴
- 행위 패턴은 객체 간의 의사소통을 돕는 패턴으로, 시스템 내 서로 다른 객체 간의 의사소통 방식을 개선하고 간소화하는 것을 목적으로 한다.
- 자바스크립트의 행위 패턴들
  - 관찰자 패턴
  - 중재자 패턴
  - 커맨드 패턴

### 관찰자 패턴
- 관찰자 패턴은 한 객체가 변경될 때 다른 객체들에 변경되었음을 알릴 수 있게 해주는 패턴이다
- 변경된 객체는 누가 자신을 구독하는지 알 필요 없이 알림을 보낼 수 있다
- 한 객체(주체)를 관찰하는 여러 객체들(관찰자)이 존재하며, 주체의 상태가 변화하면 관찰자들에게 자동으로 알림을 보낸다
- 관찰자 패턴의 구성 요소들
  - **주체** : 관찰자 리스트를 관리하고, 추가와 삭제를 가능하게 한다
  - **관찰자** : 주체의 상태 변화 알림을 감지하는 update 인터페이스를 제공한다
  - **구체적 주체(ConcreteSubject)** : 상태 변화에 대한 알림을 모든 관찰자에게 전달하고, ConcreteObserver의 상태를 저장한다
  - **구체적관찰자(ConcreteObserver)** : ConcreteSubject의 참조를 저장하고, 관찰자의 update 인터페이스를 구현하여 주체의 상태 변화와 관찰자의 상태 변화가 일치할 수 있도록 한다

#### 관찰자 패턴과 발행/구독 패턴의 차이점
- 실제 자바스크립트 환경에서는 발행/구독 패턴이라는 변형된 형태의 구현이 더 널리 사용된다
- 관찰자 패턴에서는 이벤트 발생에 대해 알림 받기를 원하는 관찰자 객체가 이벤트를 발생시키는 주체 객체에 알림 대상으로 등록되어야 한다
- 반면 발행/구독 패턴에서는 이벤트 알림을 원하는 구독자와 이벤트를 발생시키는 발행자 사이에 **토픽/이벤트 채널**을 둔다
- 이러한 이벤트 시스템을 통해 애플리케이션에 특화된 이벤트를 정의할 수 있고, 구독자에게 필요한 값이 포함된 커스텀 인자를 전달할 수 있다
- 발행/구독 패턴의 핵심은 **발행자와 구독자를 각각 독립적으로 유지**한다는 것이다.
- 이러한 점에서 관찰자 패턴과 구별되는데, 발행/구독 패턴에서는 **적절한 이벤트 핸들러를 가지고 있는 구독자라면 누구나** 발행자가 전파하는 토픽의 알림을 받게 할 수 있다
- 발행/구독 패턴의 핵심은 **시스템의 구성 요소 간에 느슨한 결합을 도모한다**는 것이다. 객체(발행자)가 다른 객체(구독자)의 메서드를 직접 호출하는 대신, 구독자는 특정 작업이나 활동을 구독하고 해당 작업이나 활동이 발생했을 때 알림을 받게 된다

#### 관찰자 패턴과 발행/구독 패턴의 장점
- 각각의 요소들이 직접 연결되어 있는 곳을 파악하여, 주체와 관찰자의 관계로 대체할 수 있는 부분을 찾아낼 수 있도록 도움을 준다
- 이를 통해 애플리케이션을 더 작고 느슨하게 연결된 부분으로 나눌 수 있고, 결과적으로 코드의 관리와 재사용성을 높일 수 있다
- 관찰자 패턴을 사용하는 또 다른 이유는 클래스를 강하게 결합시키지 않으면서 관련 객체들 사이의 일관성을 유지해야 하는 상황에 있다
- 관찰자 패턴 또는 발행/구독 패턴을 사용하면 주체와 객체 사이에 동적인 관계가 형성된다. 이를 통해 애플리케이션의 여러 부분이 강하게 결합되어 있을 때 구현하기 까다로운 뛰어난 유연성을 쉽게 구현할 수 있다
> 관찰자 패턴과 발행/구독 패턴이 모든 문제에 대한 최고의 해결책은 아닐지라도, 이 패턴들은 시스템 구성 요소 간 결합도를 낮추는 훌륭한 도구이다

#### 관찰자 패턴과 발행/구독 패턴의 단점
- 발행자/구독 패턴에서는 발행자와 구독자의 연결을 분리함으로써, 애플리케이션의 특정 부분들이 기대하는 대로 동작하고 있다는 것을 보장하기 어려워질 수 있다
- 구독자들이 서로의 존재에 대해 전혀 알 수가 없고 발행자를 변경하는 데 드는 비용을 피할 수 없다
- 구독자와 발행자 사이의 관계가 동적으로 결정되기 때문에 어떤 구독자가 어떤 발행자에 의존하는지 추적하기 어려울 수 있다

#### 발행/구독 패턴과 자바스크립트 생태계
- 발행/구독 패턴은 자바스크립트 생태계와 매우 잘 어울리는데, 왜냐하면 ECMAScript의 구현체가 본질적으로 이벤트 기반이기 때문이다
- 브라우저 환경에서는 DOM을 스크립트를 위한 주요 상호작용 API로써 사용하므로 이벤트 기반의 구조임이 더욱 뚜렷하다
- 모듈 간 높은 결합도를 가진 애플리케이션은 코드 사이에 의존성이 증가하여 기능을 재사용하기 어렵게 만들 수 있다
- 같은 데이터 소스를 다루는 여러 요청을 나중에 하나하나 수정하는 대신에 처음부터 발행/구독 패턴을 사용하면 시간을 절약할 수 있었을 것이다
- 관찰자 패턴을 사용한다면 애플리케이션 전반에 걸쳐 발생하는 다양한 이벤트의 알림을 원하는 만큼 자세한 수준으로 분리할 수 있다
- 이런 기능은 다른 패턴에서는 구현하기 어려운 기능이다

#### 리액트 생태계에서의 관찰자 패턴
- RxJS는 관찰자 패턴을 사용하는 대표적인 라이브러리이다
- ReactiveX는 관찰자 패턴, 이터레이터 패턴 그리고 함수형 프로그래밍 등의 개념을 결합하여, 이벤트의 시퀀스를 관리하는 데에 이상적인 방법을 제공한다
- 관찰자 패턴은 애플리케이션의 설계에서 여러 요소들 간의 결합도를 낮추는 데에 유용한 패턴이다

### 중재자 패턴
- 중재자 패턴은 하나의 객체가 이벤트 발생 시 다른 여러 객체들에게 알림을 보낼 수 있는 디자인 패턴이다
- 이 패턴은 하나의 객체가 다른 객체에서 발생한 특정 유형의 이벤트에 대해 알림을 받을 수 있다는 점이다
- 반면에 관찰자 패턴은 하나의 객체가 다른 객체에서 발생하는 다수의 이벤트를 구독할 수 있도록 한다
- 관찰자 패턴에 대해 설명하는 부분에서 여러 개의 이벤트 소스를 하나의 객체로 보내는 방법을 '발행/구독' 또는 '이벤트 집합'이라고 한다
- 개발자들은 이러한 문제에 직면했을 때 중재자 패턴을 고려하는 경우가 많은데, 둘이 어떻게 다른지 알아보아야 한다
- 중재자는 행위 디자인 패턴이며, 시스템의 여러 부분이 통신할 수 있는 통합된 인터페이스를 제공한다
- 시스템의 구성 요소들 사이에 직접적인 관계가 너무 많은 것 같다면 중앙 통제 포인트를 두어서 모든 구성 요소들이 이를 통해 간접적으로 소통하도록 할 때가 된 것일 수도 있다
- 중재자 패턴은 구성 요소 간의 관계를 관리함으로써 직접 참조를 없애고 느슨한 결합을 가능하게 한다. 이는 시스템 결합도를 낮추고 구성 요소의 재사용성을 높여준다
- 다른 사례로는 DOM의 이벤트 버블링과 이벤트 위임을 들 수 있다
  - 시스템의 모든 이벤트 등록이 일어날 개별 DOM 노드 대신 최상위 Document 객체를 대상으로 했을 경우 Document 객체는 사실상 중재자 역할을 하게 되는 것이다
  - 다시 말해 개별 노드 대신 Document 객체에 이벤트를 연결하고, 이벤트가 발생하면 Document 객체가 개별 노드에 알려주는 방식이다
- 중재자 패턴과 이벤트 집합 패턴의 구현이 비슷할 수 있어서 겉으로 보기엔 서로 호환이 가능해 보일 수 있지만, 두 패턴의 의미와 의도는 매우 다르다
- 중재자는 여러 객체 간의 상호작용(로직과 행동)을 조율하는 객체이다. 중재자는 다른 객체들의 행동과 입력에 따라 언제 어느 객체를 호출할지 결정한다

### 중재자 패턴과 이벤트 집합 패턴
- **유사점 1. 이벤트**
  - 이벤트 집합 패턴이 이벤트를 다루는 패턴이라는 것은 그 이름에서 알 수 있듯 명백하다
  - 반면에 중재자 패턴은 최신 자바스크립트 웹 애플리케이션 프레임워크에서 구현을 단순화하기 위해 이벤트를 활용할 뿐이다
  - 따라서 중재자 패턴이 반드시 이벤트를 다룰 필요는 없다. 대신 중재자 객체에 대한 참조를 하위 객체에 전달하거나 그 외의 수단을 사용하는 등 콜백 메서드를 통해 구현할 수 있다
  - 그러므로 두 패턴이 왜 이벤트를 사용하는지에 대해 차이점이 존재한다
  - 이벤트 집합 패턴은 그 자체로 이벤트를 처리하기 위한 목적으로 설계된 패턴이다.
  - 하지만 중재자 패턴은 단순히 편리하기 때문에 이벤트를 활용할 뿐이다
- **유사점 2. 서드 파티 객체**
  - 설계상, 이벤트 집합 패턴과 중재자 패턴 모두 상호작용을 간소화하기 위해 서드 파티 객체를 사용한다
  - 이벤트 집합 패턴 자체는 이벤트 발행자와 구독자에 대해 서드 파티 객체이며, 모든 이벤트가 통과하는 중앙 허브의 역할을 한다
  - 중재자 패턴 또한 다른 객체에 대한 서드 파티 객체이다
  - 그렇다면 차이점이 무엇일까? 왜 이벤트 집합 패턴과 중재자 패턴을 구분할까? 이에 대한 답은 애플리케이션 로직과 워크플로가 어디에 구현되어 있는지에 달려있다
  - 이벤트 집합 패턴에서 서드 파티 객체는 알 수 없는 수의 소스에서 알 수 없는 수의 핸들러로 이벤트가 연결되도록 지원하는 역할만 한다
  - 실행되어야 하는 모든 워크플로와 비즈니스 로직은 이벤트를 발생시키는 객체(소스)와 처리하는 객체(핸들러)에 직접 구현된다
  - 중재자 패턴에서 비즈니스 로직과 워크플로는 중재자 내부에 집중된다
  - 중재자는 자신이 보유한 정보를 바탕으로 각 객체의 메서드 호출 시점과 속성 업데이트의 필요성을 판단한다
  - 이를 통해 워크플로와 프로세스를 캡슐화하고 여러 객체 사이를 조율해 시스템이 원하는 대로 동작하도록 한다
  - 이벤트 집합 패턴은 ‘발행 후 망각’ 방식의 소통 모델을 사용한다
  - 이벤트를 발생시키는 객체는 구독자의 존재 여부에 상관없이 이벤트를 발행한 후 처리를 위임한다
  - 한편, 중재자 패턴은 이벤트를 의사결정에 활용할 수는 있지만 ‘발행 후 망각’과는 거리가 멀다
  - 중재자는 미리 설정해 둔 특정 입력 또는 활동에 주목함으로써 역할이 분명한 참여자(객체) 사이의 행동을 조율하고 촉진한다

#### 이벤트 집합 패턴의 활용
- 이벤트 집합 패턴은 직접적인 구독 관계가 많아질 경우 또는 전혀 관련 없는 객체들 간의 소통이 필요할 때 사용된다
- 예를 들어 부모 뷰와 자식 뷰같이 두 객체 간의 직접적인 관계가 존재하는 경우, 이벤트 집합 패턴을 사용하면 이점이 있을 수 있다
- 이벤트 집합 패턴은 간접적인 관계를 가진 객체 간의 소통이 필요한 상황에서도 유용하게 활용된다
- 최신 애플리케이션에서는 직접적인 연관성이 없는 다수의 뷰 객체들이 상호작용하는 것이 일반적이다
- 하지만 메뉴가 세부 내용을 표시하는 뷰와 강하게 결합될 경우 코드의 유지보수가 어려워지므로 바람직하지 않다

#### 중재자 패턴의 활용
- 중재자 패턴은 두 개 이상의 객체가 간접적인 관계를 가지고 있고 비즈니스 로직이나 워크플로에 따라 상호작용 및 조정이 필요한 경우에 유용하다
- 중재자 패턴을 도입함으로써 개별 뷰 간의 직접 참조로 인한 강한 결합을 방지하고, 비즈니스 로직에 따른 워크플로를 명확하고 효율적으로 모델링할 수 있다
- 중재자 패턴은 구현 세부사항에서 워크플로를 추출함으로써 보다 상위 레벨에서 워크플로를 자연스럽게 추상화한다
- 이를 통해 개발자는 워크플로 파악을 위해 개별 뷰를 분석할 필요없이 전체적인 흐름을 더욱 빠르게 파악할 수 있다

#### 중재자 패턴과 퍼사드 패턴
- 중재자 패턴은 모듈이 명시적으로 중재자를 참조함으로써 모듈 간의 상호작용을 중앙집중화한다
- 이는 본질적으로 다방향성을 지닌다
- 반면에 퍼사드 패턴은 모듈 또는 시스템에 직관적인 인터페이스를 제공하지만 추가 기능을 구현하지는 않는다
- 시스템 내 다른 모듈은 퍼사드의 개념을 직접적으로 인지하지 못하므로 단방향성을 지닌다

### 커맨드 패턴
- 커맨드 패턴은 메서드 호출, 요청 또는 작업을 단일 객체로 캡슐화하여 추후에 실행할 수 있도록 해준다
- 이를 통해 실행 시점을 유연하게 조정하고 호출을 매개변수화할 수도 있다
- 또한 커맨드 패턴은 명령을 실행하는 객체와 명령을 호출하는 객체 간의 결합을 느슨하게 하여 구체적인 클래스(객체)의 변경에 대한 유연성을 향상시킨다
- 구체 클래스(또는 구상 클래스)는 클래스 기반 프로그래밍 언어에서 중요한 개념으로, 추상 클래스와도 연관이 있다
- 추상 클래스는 인터페이스를 제공하지만 모든 멤버 함수의 구현을 제공하지는 않는다
- 추상 클래스는 상속을 통해 구체화되는 기초 클래스의 역할을 한다
- 커맨드 패턴의 기본 원칙은 명령을 내리는 객체와 명령을 실행하는 객체의 책임을 분리한다는 것이다
- 커맨드 패턴은 이러한 책임을 다른 객체에 위임함으로써 역할 분리를 실현한다
- 구현 측면에서 단순 커맨드 객체는 ‘실행할 동작’과 ‘해당 동작을 호출할 객체’를 연결한다
- 커맨드 패턴의 요 장점은 인터페이스가 동일한 모든 커맨드 객체를 쉽게 교체할 수 있다는 점이다
