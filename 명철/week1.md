# 1주차

## 01 디자인 패턴 소개

- 디자인패턴: 코드를 체계화하기 위한 공통적인 패턴

  - 이러한 패턴을 바탕으로 코드를 쉽게 이해하도록 돕는다.
  - 다른 개발자와의 의사소통을 원활하게 해준다.
  - 반복되는 주제에 대한 적절한 솔루션을 이끌어준다.
  - 유지보수가 쉽게 해준다.

- 패턴: 반복되는 주제에 적용할 수 있는 재사용 가능한 템플릿
- 디자인 패턴이 유용한 이유
  1. 검증되었다.
  2. 쉽게 재사용할 수 있다.
  3. 알아보기 쉽다.
  4. 사소한 실수로 발생할 큰 문제를 방지한다.
  5. 종합적인 해결책을 제시한다.
  6. 코드의 반복을 피할 수 있다.
  7. 의사소통이 원활해진다.
  8. 커뮤니티의 선순환을 유발한다.

> 패턴은 완벽한 해결책이 아니고, 단지 체계화된 방법을 제시할 뿐이다. 따라서 좋은 설계자는 언제나 필요하다.

## 02 패턴성 검증, 프로토 패턴 그리고 세 가지 법칙

- 패턴은 '과정'인 동시에 '결과'
- 패턴을 실제로 적용했을 때 나타나는 구조를 시각적으로 표현할 수 있어야 한다.
- 프로토패턴: 아직 패턴성 검증을 모두 통과하지 않은 미숙한 패턴
- 좋은 패턴의 특징
  1. 특정 문제를 해결할 수 있다
  2. 명쾌한 해결책이 없다. -> 간접적으로 해결하도록 한다.
  3. 확실한 기능만을 말한다.
  4. 관계를 설명한다 - 코드와의 관계를 나타내는 심층 구조와 메커니즘을 서술해야 한다.
- 반복되는 현상, 또는 문제에서 지속적으로 사용되어야 한다.
- 반복성 입증의 세 가지 법칙
  1. 목적 적합성
  2. 유용성
  3. 적용 가능성

## 03 패턴 구조화 및 작성

- 컨텍스트, 집중 목표, 구성의 형태로 패턴을 제시한다.
- 디자인 패턴의 구조와 만들어진 목적을 이해하면 해당 패턴이 필요한 이유에 대해 더 깊게 이해할 수 있다.
- 코드가 어떤 패턴을 사용하는 것 같으면 해당 코드의 특징을 메모하기
- 이미 존재하는 패턴으로 만드는게 더 좋은 방법이다
- 기존 디자인 패턴을 적용시 체크리스트
  [ ] 얼마나 실용적인가?
  [ ] 모범 사례를 염두에 두기
  [ ] 사용자에게 솔직해야 한다
  [ ] 독창성은 패턴 설계의 핵심이 아니다
  [ ] 훌륭한 예시가 필요하다

## 안티 패턴

안티 패턴: 잘못된 패턴을 의미한다. 겉으로는 해결한 것 같지만 문제를 가지고 있다.

- 나쁜 디자인 패턴이 안티 패턴이라는 것을 빠르게 인지할 수 있다면 개발자는 패턴을 잘못 도입하는 실수를 피할 수 있다
- 반면교사로 삼기 위해 안티패턴도 기억하고 문서화해야 한다.

---

## 이야기거리

# 공식문서의 리액트적 사고

본격적인 리액트 디자인 패턴 공부에 앞서 공식문서에 나와 있는 리액트로 사고하기를 짚고 넘어가면 좋을 것 같아요.
리액트로 사고하기에 위배되는 내용들이 리액트의 안티패턴이 되지 않을까 싶습니다.

1. UI를 컴포넌트 계층으로 쪼개기

   - UI를 여러 컴포넌트로 쪼개봅니다.
   - 단일책임 원칙을 반영하고자 한다면, 컴포넌트는 한 번에 한가지 일만 해야하므로, 컴포넌트가 커진다면 쪼개야합니다.
   - 쪼개진 컴포넌트를 계층 구조로 정리합니다.

2. React 정적인 버전 구현하기

   - 더미데이터 또는 데이터 모델로부터 정적인 UI를 만듭니다.
   - **정적인 UI를 만들 때에는 `state`를 사용하지 않기**

3. 최소한의 데이터만 이용해서 완벽하게 UI State 표현하기

   - state를 사용하여 상호작용이 가능하도록 UI를 고칩니다.
   - state는 앱이 기억하는, `변경할 수 있는 데이터의 최소 집합` 입니다.
   - **DRY(중복배제)원칙을 준수하여, state를 최소로 두도록 고려해야합니다.**
   - state로 두지 말아야하는 세가지 (그 외는 ok)
     1. 시간이 지나도 변하지 않을 때
     2. 부모로부터 props로 전달받을 때
     3. 컴포넌트 안의 다른 state나 props로 계산이 가능할 때

4. State가 어디에 있어야 할 지 정하기
   - 어떤 컴포넌트가 state를 소유하고 변경할 책임을 지게 할 지 결정합니다.
     1. state를 쓰는 컴포넌트를 찾기
     2. 1번의 컴포넌트들의 공통 부모를 찾기
     3. 부모로 위임할 state는 올리고, prop로 받기
5. 역 데이터 흐름 추가하기
   - 이벤트 핸들러도 props로 내려주기
