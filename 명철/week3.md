# 3주차

## 팩토리 패턴
- 객체를 생성하는 생성 패턴
- 동적인 요소나 애플리케이션 구조에 깊게 의지하는 상황처럼 객체 생성 과정이 복잡할 때 유용
  - 객체나 컴포넌트의 생성 과정이 높은 복잡도를 가질 때
  - 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
  - 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다룰 때
  - 같은 API 규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 구성 할 때
  - (?) 디커플링에도 유용하다 - 디커플링: 서로 다른 부분 사이의 의존성을 줄이는 것
- 쓰면 안 될 때
  - 객체 생성 인터페이스 제공이 목적이 아닐 때
  - 단위 테스트의 복잡성이 증가 (생성 과정이 추상화되기 때문)

### 추상 팩토리 패턴
- 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴
  - 여러 타입의 객체로 작업해야 하는 경우

## 퍼사드 패턴
- 사용하기 편리한 높은 수준의 인터페이스를 제공하는 패턴
  - 클래스의 인터페이스를 단순화
  - 코드의 구현부와 사용부를 분리
  - 사용하고 구현하기 쉽다

## 믹스인
- 기능을 재사용하기 위해 사용
- 객체 인스턴스 사이에 공유되는 기능이 있다면 분리하여 고유 기능에 집중
- 프로토타입 오염과 함수의 출처 불확실성 초래 우려

## 데코레이터 패턴
- 코드의 재사용을 목표로 사용
- 내부 코드의 변경 없이 기존 클래스에 동적으로 기능을 추가하기 위함
- 애플리케이션의 기능이 다양한 타입의 객체를 필요로 할 수도 있기에 주로 사용
- 기능의 확정에 초점

### 의사 클래스 데코레이터
#### 인터페이스
- 객체가 가져야할 메서드를 정의하는 방법
- 스스로 문서의 역할을 하고 재사용성을 높임

#### 추상 데코레이터
- 모든 추가 옵션과 조합에 대한 서브클래스가 필요하지 않기 때문에
- 추상화된 데코레이터를 만들로 서브클래싱한 데코레이터를 쓴다?

주의할점
- 네임스페이스에 작고 비슷한 객체를 추가하기 때문에 관리 필요

## 플라이웨이트 패턴
반복되고 느리고 비효율적으로 데이터를 공유하는 코드를 최적화. 메모리 최소화에 주 목적
- 비슷한 객체나 구조에서 공통으로 사용되는 부분을 외부 객체로 내보낸다
- 하나의 의존 외부 데이터에 모아서 저장할 수 있다.

### 사용법
- 데이터 공유
  - 내재적 상태: 객체의 내부 메서드에 필요한 것. 없으면 작동 X
    - 팩토리 메소드를 사용해 하나의 공유된 객체로 대체
  - 외재적 상태: 정보가 제거되어 외부에 저장될 수 있는 것.
    - 별도의 관리자 사용
- 전통적 구현 방법
  - 플라이웨이트
    - 외부의 상태를 받아 작동할 수 있게 하는 인터페이스
  - 구체적 플라이웨이트
    - 플라이웨이트 인터페이스를 실제로 구현. 내부 상태를 저장
    - 다양한 컨텍스트 사이에서 공유 되어야함
    - 외부 상태를 조작할 수 있어야함
  - 플라이웨이트 팩토리
    - 플라이웨이트 객체를 생성하고 관리
    - 플라이웨이트를 공유할 수 있도록 보장
    - 개별 인스턴스가 필요할 때 재사용할 수 있도록 관리
    - 135p implementsFor 이해가 잘 안 댐 ㅠ
---

## 이야깃거리
- 우리가 사용하는 곳에서 플라이웨이트 패턴이 적용되어 보이는 곳은 어디일까?
- 코드 짜는게 이렇게 어려웠니