# Chapter 05. 최신 자바스크립트 문법과 기능

## 5.1 애플리케이션 분리의 중요성

- 모듈을 사용하여 의존성을 낮추고 유지 보수를 용이하게 해준다

## 5.2 모듈 가져오기와 내보내기

## 5.3 모듈 객체

## 5.4 외부 소스로부터 가져오는 모듈

## 5.5 정적으로 모듈 가져오기

- 초기에 모든 모듈을 가져와야 하므로 성능 문제 가능성

## 5.6 동적으로 모듈 가져오기

- 지연 로딩(Lazy-loading) 으로 필요한 시점에 로딩 가능, Promise 형태로 네임스페이스를 가져와서 필요할 때 가져온다

### 5.6.1 사용자 상호작용에 따라 가져오기

- 상호작용시에 필요한 채팅, 다이얼로그 등은 상호 작용에 따라 가져오는 방법도 존재

### 5.6.2 화면에 보이면 가져오기

- 화면에 컴포넌트가 보이는지에 따라 로딩도 가능

## 5.7 서버에서 모듈 사용하기

## 5.8 모듈을 사용하면 생기는 이점

- 한 번만 실행
- 자동으로 지연 로드
- 유지보수와 재사용이 쉽다
- 네임스페이스 제공
  - 전역 스페이스를 오염시키지 않는다
- 사용하지 않는 코드를 제거
  - 웹팩으로 자동 제거 가능(= 트리쉐이킹)

## 5.9 생성자, 게터, 세터를 가진 클래스

- 클래스의 대부분의 개념을 JS 의 Prototypes 을 기반하여 사용 가능
- 게터, 세터, 상속, super 등 사용 가능
- private 는 # 으로 구현한다

## 5.10 자바스크립트 프레임워크와 클래스

## 5.11 마치며

# Chapter 06. 디자인 패턴의 유형

## 6.1 배경

- 모든 디자인 패턴은 설계의 문제나 이슈에 초점을 맞춘다
- 디자인 패턴의 3가지 유형 -> 생성 / 구조 / 행위 패턴

## 6.2 생성 패턴

- 주어진 상황에 적합한 객체를 생성하는 방법
- 생성하는 과정을 제어하여 문제를 해결하는데 중점
- 생성자, 팩토리, 추상, 프로토타입, 싱글톤, 빌더 패턴

## 6.3 구조 패턴

- 객체의 구성과 객체 간의 관계에 중점
- 어느 한 부분이 변경되어도 다른 부분에 영향이 가지 않도록 도움을 주며, 설계 목적에 맞지 않는 부분을 개선하는데 도움
- 데코레이터, 퍼사드, 플라웨이트, 어댑터, 프록시 패턴

## 6.4 행위 패턴

- 객체 간 커뮤니케이션을 개선하거나 간소화하는 방법에 중점
- 공통적인 커뮤니케이션 패턴을 감지 및 책임 분배를 통해 커뮤니케이션의 유연성을 높이고, 객체 행위를 추상화
- 이레이터, 중재자, 관찰자, 방문자 패턴

## 6.5 디자인 패턴의 분류

# Chapter 07. 자바스크립트 디자인 패턴

## 7.1 생성 패턴

## 7.2 생성자 패턴

### 7.2.3 프로토타입을 가진 생성자

- 각각의 객체에 toString 메서드가 중복 되는 것을 피하기 위해 프로토타입 객체에 메서드를 등록하여 공통 사용
  > Java 의 경우, 공통 메서드의 경우 메서드 영역(static)에 메서드를 등록하여 각각의 인스턴스가 해당 메서드를 참조하는 형태를 이용한다

## 7.3 모듈 패턴

### 7.3.1 객체 리터럴

- 객체 리터럴을 사용하면 new 키워드 없이 객체를 생성하여 사용 -> 코드 캡슐화를 간단하게 구현이 가능
  > 클래스를 사용하면 클래스 정의 후, 클래스를 인스턴스화 하여 객체를 만들어야 하는 과정이 필요
  > 따라서 2 단계를 생략 가능하다. 다만, 요건 JS 이기 때문에 가능

```js
const myModule = {
  myProperty: 'value',
  say() {
    console.log('Hi');
  },
};
```

### 7.2.3 모듈 패턴

- 과거에는 각각 수동으로 스크립트를 가져와야 했지만, 모듈의 등장으로 쉽게 다른 파일로 내보내거나 가져올 수 있게 되었다

#### 비공개

- 모듈 패턴은 클로저를 사용하여 '비공개' 상태 및 캡슐화를 구현
  > 클래스의 private 멤버를 클로저를 통해 구현하는 개념
  > ES2019 에는 private 역할을 하는 # 이 없어서 제한적 의미의 비공개 개념이었지만, 이제는 실제로 지원
- 특정 변수에 대한 접근을 해당 모듈의 특정 메서드만 접근 가능하도록 하여 캡슐화를 완성
  > 전역에서는 해당 변수에 접근이 불가능
- 이를 통하여 비공개 실현 및 디버깅 용이성을 가진다

### 7.3.3 모듈 패턴의 변형

#### 믹스인 가져오기 변형

- 유팅 함수나 외부 라이브러리를 내부 함수의 인자로 전달하여 활용이 가능

#### 내보내기 변형

- 전역으로 내보내서 바로 사용이 가능한 변형

#### 장점

- 클래스와 인스턴스, 객체에 대한 이해 없이 편리하게 이해가 가능
- 모듈 단위로 의존성이 관리되어 유지 보수가 용이하며 독립성 증대
- 비공개 지원 및 캡슐화 구현

#### 단점

- public 과 private 멤버를 서로 다르게 접근해야 하는 문제
- 핫 픽스 발생 시, private 멤버에 대한 수정의 복잡성이 증대

### 7.3.4 WeakMap을 사용하는 최신 모듈 패턴

- 키가 문자열이 반드시 객체여야 하는 형태의 최신 Map 데이터 타입(컬렉션)

```js
const privateData = new WeakMap();

// 키로 사용 할, 객체 생성
let user = { name: '이효석' };

// WeakMap에 데이터 저장
privateData.set(user, { isOld: true });
console.log(privateData.get(user));

// user 객체에 대한 참조 제거, 인스턴스에 대한 참조가 제거 되면 GC 가 처리
user = null;

// 새로운 객체 생성
let anotherUser = { name: '장경은' };

console.log(privateData.has(anotherUser)); // false
```

### 7.3.5 최신 라이브러리와 모듈

## 7.4 노출 모듈 패턴

- 모든 함수와 변수를 비공개 스코프에 정의하고, 공개하고 싶은 부분만 포인터를 통해 비공개 요소에 접근하는 익명 객체를 반환하는 패턴

```js
const Calculator = (function () {
  // private 변수, 외부에서 접근 불가
  let result = 0;

  // private 함수, 외부에서 접근 불가
  function validateNumber(num) {
    if (typeof num !== 'number') {
      throw new Error('숫자만 입력 가능합니다.');
    }
  }

  // public 메서드, 내부에서는 private 메서드 및 변수 접근 가능
  function add(num) {
    validateNumber(num);
    result += num;
    return result;
  }

  // public 인터페이스만 노출
  return {
    add: add,
  };
})();

// 사용 예시
console.log(Calculator.add(5)); // 5
```

### 7.4.1 장점

- 코드의 일관성 유지

\*\* [p. 94] 그런 이거 문서 구조 뭡니까? 좀 킹받네요 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

### 7.4.2 단점

- 비공개 멤버 또는 함수가 참조되면 수정이 어렵다

## 7.5 싱글톤 패턴

- 클래스의 인스턴스가 오직 하나만 존재하는 패턴

  > 동일 인스턴스가 여러개인 경우, 프레임워크 레벨에서 어떤 인스턴스를 사용해야할지 판단이 어렵다
  > 인스턴스의 멤버의 값도 각기 다르게 유지되기 때문에 더더욱 문제가 발생할 가능성이 높다
  > 스프링 프레임워크의 의존성 역전에 의한(DI) 인스턴스 주입을 통해 서비스를 다양화 하기 때문에 더더욱 싱글톤 패턴이 지켜져야 한다
  > 리액트에서 동일한 기능을 하는 버튼 컴포넌트의 text 가 다르다고 모든 text 에 대응하는 버튼 컴포넌트를 만드는 것 보다는 하나의 버튼 컴포넌트를 만들고 props 를 전달하는 방식이 편한 것과 같은 이치

- 데이터베이스 커넥션을 하나의 싱글톤 인스턴스로 관리하는 코드

```js
// 싱글톤 클래스 정의
class DatabaseConnection {
  constructor() {
    if (DatabaseConnection.instance instanceof DatabaseConnection) {
      return DatabaseConnection.instance;
    }

    this.connectionString = '';
    this.isConnected = false;
    DatabaseConnection.instance = this;
  }

  connect(connectionString) {
    if (this.isConnected) {
      console.log('이미 연결되어 있습니다.');
      return;
    }

    // 연결 로직 필요
    this.connectionString = connectionString;
    this.isConnected = true;
    console.log(`연결됨: ${this.connectionString}`);
  }

  disconnect() {
    if (!this.isConnected) {
      console.log('연결되어 있지 않습니다.');
      return;
    }

    // 해재 로직 필요
    this.isConnected = false;
    console.log('연결 해제됨');
  }

  executeQuery(query) {
    if (!this.isConnected) {
      console.log('데이터베이스에 연결되어 있지 않습니다.');
      return;
    }

    // DB에 따른 쿼리 로직 필요
    console.log(`쿼리 실행: ${query}`);
  }
}

// 싱글톤 사용 예시
const connection1 = new DatabaseConnection();
const connection2 = new DatabaseConnection();

// 커넥션을 2개 만들어도 하나의 인스턴스에 의해 처리
connection1.connect('mongodb://localhost:27017/mydb');
connection2.executeQuery('SELECT * FROM users');

connection1.disconnect();
connection2.executeQuery('SELECT * FROM products'); // 연결되어 있지 않음 메시지 출력
```

- JS 에서는 싱글톤이 필요하면 설계를 다시해야하는 고민을 할 필요가 있다

  - JS 에서는 클래스 없이 바로 객체의 직접 생성이 가능하기 때문에 JAVA 와 달리 다른 대안적 처리가 가능하다
  - 상태 관리는 Redux 등의 상태 관리 사용
  - 데이터 베이스 연결 및 로깅 등의 전역 서비스는 util 모듈 객체를 전달하는 방식으로 처리가 가능

\*\* [p. 99] 그런데 모듈을 쓰는 것은 싱글톤과 같은 개념이 아닐까요? 모듈은 필요시에 최초 import 되어 로딩 된 이후, 추후 사용시에는 해당 로딩 된 모듈이 참조되는 형태를 가지는데 사실 클래스 -> 인스턴스가 모듈로 대체만 되었을 뿐 같은 개념으로 보입니다. 어떻게 생각하시나요?

- JS 에서 싱글톤을 사용하는 단점
  - 싱글톤임을 파악하기 어렵다 (객체 생성이 자유로운 JS 구조로 인해 해당 부분까지 고려가 쉽지 않은듯)
  - 숨겨진 의존성, 여러 인스턴스 생성의 어려움 등등 단위 테스트하기 힘들다
  - 싱글톤의 특성상 전역에 걸쳐 데이터를 저장하게 되므로 실행 순서등에 있어서 신중한 조정이 필요하다

### 7.5.1 리액트의 상태 관리

- 상태 관리적 측면에서 JS 에서는 싱글톤 패턴보다는 상태 관리 라이브러리가 용이하다

## 7.6 프로토타입 패턴

- 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새로운 객체를 생성하는 패턴
- 상속과 유사하게 작동하나 JS 만의 고유한 개념이며 성능상의 이점이 존재한다.
  - 앞서 동일 메서드를 계속 만드는 것이 아니라 프로토타입으로 같은 메서드를 참조하게 하는 방식

<hr />

# 이야기 거리

- JS 에서 패턴이 덜 언급 되는 것 자체가, 언어가 가지는 자유로움으로 인한 것으로 생각이 됩니다. Java 의 경우 언어 자체의 제약이 많아 해당 제약을 지키면서 특정 목적을 이루기 위해서 패턴이 많이 사용 된 것으로 생각됩니다. 반면 JS 의 경우는 그 당시에 필요한 기능을 빠르게 차용하는 형태로 발전이 되어서 패턴 보다는 해당 패턴 없이 구현이 가능한 형태로 발전되어 왔기 때문에 상대적으로 패턴이라는 이름보다는 특정 기능에 대한 유명 라이브러리(모듈)이 많은 형태로 발전하고 있지 않나 싶네요. 다들 어떻게 생각하시나요?
- [p. 99] 그런데 모듈을 쓰는 것은 싱글톤과 같은 개념이 아닐까요? 모듈은 필요시에 최초 import 되어 로딩 된 이후, 추후 사용시에는 해당 로딩 된 모듈이 참조되는 형태를 가지는데 사실 클래스 -> 인스턴스가 모듈로 대체만 되었을 뿐 같은 개념으로 보입니다. 어떻게 생각하시나요?
- 최근 어찌저찌 백엔드 쪽도 강의를 하다보니 Java 및 스프링에 대한 이해도가 많이 올라가게 되었는데 이러한 부분이 JS 그리고 프론트 파트에 대한 전체적인 이해도 올라가는 영향을 주는 듯 합니다. 다들 Java 정도는 한번 공부 해보시는거 추천 드립니다! 김영한님 강의 강추 드립니다 :)
