### 7.17 행위 패턴

### 7.18 관찰자 패턴

- 한 객체가 변경될 때 다른 객체들에 변경되었음을 알릴 수 있게 해주는 패턴
    - 주체: 관찰자 리스트를 관리하고, 추가 삭제를 가능케 함
    - 관찰자: 주체의 상태 변화 알림을 감지하는 update 인터페이스를 제공
    - 구체적 주체: 상태 변화에 대한 알림을 모든 관찰자에게 전달하고, ConcreteObserver의 상태를 저장함 // 주체 인터페이스를 구현한 클래스
    - 구체적 관찰자: ConcreteSubject의 참조를 저장하고, 관찰자의 update 인터페이스를 구현하여 주체의 상태 변화와 관찰자의 상태 변화가 일치할 수 있도록 함. // 관찰자 인터페이스를 구현한 클래스

### 7.18.1 관찰자 패턴과 발생/구독 패턴의 차이점

- 관찰자 패턴에서는 이벤트 발생에 대해 알림 받기를 원하는 관찰자 객체가 이벤트를 발생시키는 주체 객체에 알림 대상으로서 등록되어야 함
- pub/sub에서는 이벤트 알림을 원하는 구독자와 이벤트를 발생시키는 발행자 사이에 토픽/이벤트 채널을 둠. 발행자와 구독자를 각각 독립적으로 유지함. 적절한 이벤트 핸들러를 가지고 있는 구독자라면 누구나 발행자가 전파하는 토픽의 알림을 받을 수 있게 함.

### 7.18.2 장점

- 애플리케이션을 더 작고 느슨하게 연결된 부분으로 나눔 → 코드 관리와 재사용성 높임

### 7.18.3 단점

- pub/sub에서는 발행자와 구독자의 연결을 분리함으로써, 애플리케이션의 특정 부분들이 기대하는 대로 동작하고 있다는 것을 보장하기 어려워짐
- 구독자들이 서로의 존재에 대해 전혀 알 수 없고 발행자를 변경하는 데 드는 비용을 파악할 수 없음. 어떤 구독자가 어떤 발행자의 의존하는지 추적하기 힘듦.

### 7.19 중재자 패턴

- 하나의 객체가 이벤트 발생 시 다른 여러 객체들에게 알림을 보낼 수 있는 패턴
- 관찰자 패턴과의 차이점은 하나의 객체가 다른 객체에서 발생하는 다수의 이벤트를 구독하는 게 아니라, 하나의 객체가 다른 객체에서 발생한 **특정 유형의 이벤트**에 대해 알림을 받는다는 것
- 예시: dom의 이벤트 버블링과 이벤트 위임

### 7.19.2 유사점과 차이점

- 이벤트
    - 왜 이벤트를 사용하는지 차이점이 존재함. 이벤트 집합 패턴은 그 자체로 이벤트를 처리하기 위한 목적으로 설계된 패턴. 중재자 패턴은 단순히 편리하기 위해서 이벤트를 활용할 뿐, 반드시 이벤트를 활용해야 하는 것은 아님
- 서드 파티 객체
    - 상호작용 간소화를 위해 모두 서드 파티 객체를 사용함. 다만 애플리케이션 로직과 워크 플로우가 어디에 구현되어 있는지가 다름. 이벤트 집합 패턴은 이것들이 이벤트를 발생시키는 객체와 처리하는 객체에 직접 구현됨(발행 후 망각). 중재자 패턴은 중재자 내부에 집중됨(캡슐화)

### 7.19.3 이벤트 집합 패턴의 활용

- 직접적인 구독 관계가 많아질 경우 || 전혀 관련 없는 객체들 간의 소통이 필요할 때

### 7.19.4 중재자 패턴의 활용

- 두 개 이상의 객체가 간접적인 관계를 가지고 있고 비즈니스 로직이나 워크플로에 따라 상호작용 및 조정이 필요한 경우

### 7.19.5 이벤트 집합 패턴과 중재자 패턴 결합하기

- 결합해서 사용도 가능하다

### 7.19.7 중재자 패턴 vs 퍼사드 패턴

- 중재자 패턴은 모듈이 명시적으로 중재자를 참조함으로써 모듈 간의 상호작용을 중앙 집중화
- 퍼사드 패턴은 모듈 또는 시스템에 직관적인 인터페이스를 제공하지만, 추가 기능을 구현하지는 않음. 단반향성.

### 7.20 커맨드 패턴

- 메서드 호출, 요청 또는 작업을 단일 객체로 캡슐화하여 추후에 실행할 수 있도록 해줌
- 실행 시점을 유연하게 조정하고 호출을 매개변수화 할 수 있음
- 명령을 실행하는 객체와 호출하는 객체 간의 결합을 느슨하게 해서 객체의 변경에 대한 유연성을 향상시킴
- 기본 원칙은 명령을 내리는 객체와 명령을 실행하는 객체의 책임을 분리한다는 것

## Chapter 08. 자바스크립트 MV* 패턴

### 8.1 MVC 패턴

### 8.1 Smalltalk-80의 MVC 패턴

- 모델: 도메인 관련된 데이터를 표현했으며 UI에 대해서는 관여하지 않음. 모델이 변경되면 자신의 관찰자 객체에게 알림을 보냄
- 뷰: 모델의 현재 상태를 표현. 관찰자 패턴을 사용해 모델이 변경되거나 수정될 때마다 뷰가 알아차릴 수 있도록 함. 뷰는 화면에 보여지는 프레젠테이션 부분만 담당했지만, 화면에 표시되는 각 섹션 또는 요소에는 언제나 뷰-컨트롤러 쌍이 존재
- 컨트롤러: 키보드 입력이나 클릭 같은 상호작용을 처리하고 뷰에 무엇을 보여줄지, 사용자 입력을 어떻게 처리할지 결정

### 8.2 자바스크립트의 MVC

### 8.2.1 모델

- 애플리케이션의 데이터를 관리. UI나 프레젠테이션 계층은 담당하지 않음.
- 모델이 변경될 때 관찰자에게 변경사항을 알림
- 비즈니스 데이터와 주로 관련이 있음

### 8.2.2 뷰

- 모델에 대한 시각적인 표현으로 현재 상태의 특정 부분만 보여줌
- 일반적으로 뷰는 모델을 관찰하고 모델에 변화가 생기면 알림을 받음. 이를 통해 뷰는 스스로 업데이트 함
- 사용자는 뷰와 상호작용할 수 있음. 모델을 실제로 업데이트 하는 작업은 컨트롤러가 담당(뷰가 위임함).

### 8.2.3 탬플릿

- 탬플릿 자체가 뷰는 아님. 탬플릿은 뷰 객체의 일부 또는 전체를 선언적으로 지정하는 방법이 될 수 있을 뿐.

### 8.2.4 컨트롤러

- 모델과 뷰 사이의 중재자 역할. 일반적으로 사용자가 뷰를 조작할 때 모델을 업데이트 하는 역할을 함.

### 8.3 MVC를 사용하는 이유?

- 관심사 분리 → 더 간단한 모듈로 분리 가능
    - 전반적인 유지보수의 단순화
    - 모델과 뷰의 분리
    - 애플리케이션 전반에서 하위 수준의 모델 및 컨트롤러 코드 중복이 제거
    - 애플리케이션의 규모와 역할의 분리 정도에 따라, 모듈화를 통해 코어 로직을 담당하는 개발자와 UI를 담당하는 개발자가 동시에 작업할 수 있음

### 8.6 MVP 패턴

- 프레젠테이션 로직의 개선에 초점을 맞춘 MVC 디자인 패턴의 파생

### 8.6.1 모델, 뷰, 프레젠터

- 프레젠터는 뷰에 대한 UI 비즈니스 로직을 담당하는 구성 요소. 뷰에서의 이벤트 호출은 컨트롤러가 아닌 프레젠터로 위임됨. 인터페이스를 통해 뷰와 통신함.
- 모델이 이벤트를 발생시킬 수도 있지만, 이벤트를 구독하여 뷰를 업데이트 할 수 있도록 하는 게 프레젠터의 역할
- MVC → MVP이ㅡ 변화는 테스트 용이성을 높이고 뷰와 모델 간의 분리를 더욱 명확하게 해줌. 하지만 MVP 패턴에서는 데이터 바인딩이 지원되지 않아서 별도 작업이 필요함

### 8.6.2 MVP vs MVC

- MVP
    - 프레젠테이션 로직을 최대한 재사용해야 하는 애플리케이션(뷰가 매우 복잡하고 사용자와의 상호작용이 많은 애플리케이션)

### 8.7 MVVM 패턴

- 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리함

### 8.7.2 모델

- 기존 모델을 정의하거나 업데이트 하는 데 사용되는 데이터에 대한 유효성 검사는 모델에서 수행

### 8.7.3 뷰

- 사용자가 상호작용하는 유일한 부분이고, 뷰모델의 상태를 표현하는 상호작용이 가능한 UI
- 능동적 뷰는 데이터 바인딩, 이벤트, 동작을 포함
- 뷰는 상태를 관리할 책임이 없음. 뷰모델과 정보 또는 상태를 항상 동기화된 상태로 유지함

### 8.7.4 뷰모델

- 데이터 변환기의 역할을 하는 특수한 컨트롤러. 모델의 정보를 뷰가 사용할 수 있는 형태로 변환하고, 뷰에서 발생한 명령을 모델로 전달
- 뷰모델은 UI 계층의 뒤에 위치함. 뷰가 필요한 데이터를 모델로부터 가져와 제공하고, 데이터와 사용자의 동작 모두를 뷰가 참조하는 출처의 역할을 할 수 있음
- 모델에 대한 전적인 책임을 짐

### 8.8.1 장점

- UI와 구동하게 해주는 요소를 동시에 개발 가능함
- 뷰를 추상화함으로써 뷰의 뒤에 작성되는 비즈니스 로직(혹은 연결 코드)의 양을 줄여줌
- 이벤트 중심 코드에 비해 단위 테스트가 더 쉬움
- 뷰모델은 UI 자동화나 상호작용에 대한 고려 없이도 테스트가 가능함

### 8.8.2 단점

- 단순한 UI의 경우 과도한 구현이 될 수 있음
- 데이터 바인딩은 선언적이고 사용하기 편리할 수 있지만, 단순히 중단점을 설정하는 명령형 코드에 비해 디버깅이 어려울 수 있음
- 복잡한 애플리케이션에서는 데이터 바인딩이 상당한 관리 부담을 만들 수 있음. 또한 바인딩 코드가 바인딩 대상 객체보다 더 무거워질 수 있음
- 대규모 애플리케이션에서는 뷰모델을 미리 설계하는 게 어려울 수 있음

### 8.9 MVC vs MVP vc MVVM

- 각 계층이 다른 계층에 갖는 의존성과 서로 얼마나 강하게 연결되어 있는지 차이점이 있을 뿐
- MVC에서는 뷰가 아키텍처의 최상단에 위치하고 있고 그 옆에 컨트롤러가 있음. 모델은 컨트롤러 아래에 있기 때문에 뷰는 컨트롤러에 대해 알고 있고, 컨트롤러는 모델에 대해 알고 있음. 뷰는 모델에 직접 접근할 수 있음. 전체 모델을 뷰에 노출하는 건 애플리케이션의 복잡도에 따라 보안 및 성능상 문제가 일으킬 수 있음 → MVVM
- MVP에서는 프레젠터가 뷰와 동일한 계층에 존재하며, 뷰와 모델 양쪽에서 발생하는 이벤트를 수신하고 이들 간의 동작을 조정함. 각 뷰는 프레젠터가 뷰와 상호작용할 수 있도록 인터페이스를 구현함

### 8.10 최신 MV* 패턴

- Vue는 MVVM이라고 주장…

### 8.10.1 MV* 패턴과 리액트

- 리액트는 뷰 계층을 원하는대로 구성하게 해주는 렌더링 라이브러리입니다. 기존 MVC처럼 중앙 제어 역할을 하는 컨트롤러, 혹은 라우터 기능이 포함되어 있지 않음
- 선언형 프로그래밍을 따름. 즉, 개발자는 애플리케이션이 원하는 상태를 기술하고 리액트는 그 상태를 기반으로 적절한 뷰를 렌더링 함.
- 리액트는 MVC를 기술에 따라 수평적으로 나누는 대신 관심사에 따라 수직적으로 나눔. 리액트의 컴포넌트는 상태(모델), 렌더링(뷰), 제어 흐름 로직(소규모의 지역화된 컨트롤러)를 담고 있는 작은 수직 분할형 MVC로 시작함
- 컴포넌트 로직이 hooks으로 구성됨에 따라 컴포넌트를 뷰로, hooks를 컨트롤러로 볼 수도 있음. ‘모델 ⇒ 비동기 데이터, 뷰 ⇒ 컴포넌트, 컨트롤러 ⇒ hook’

## 이야기 거리

- MV* 패턴 나오니까 좀 숨통 트이는 거 같네요 ㅎ…
- **리액트는 MVC를 기술에 따라 수평적으로 나누는 대신 관심사에 따라 수직적으로 나눔.** 이 문구가 인상 깊었어요. 최근에 [관심사의 분리와 관련된 글](https://velog.io/@teo/separation-of-concerns-of-frontend)을 읽었는데, 거기서도 이런 말을 하더라구요. 그리고 최근에는 다시 계층적 관심사로 돌아가고자 하는 의견이 나오는 것 같은데 이런 흐름이 신기했어요.
