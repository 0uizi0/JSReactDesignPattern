## 12.4 리액트 Hooks 패턴

- Class 컴포넌트 없이 상태, 라이프사이클 메서드를 활용 가능

### 12.4.1 클래스 컴포넌트

- 클래스 컴포넌트 특징
    - 생성자 함수 내의 상태
    - 컴포넌트의 라이프사이클에 따른 효과를 처리하기 위한 componentDidMount, componentWillUnmount 같은 라이프사이클 메서드
    - 추가적인 로직을 구현하기 위한 커스텀 메서드

### 12.4.2 구조 변경의 필요성 && 12.4.3 복잡성 증가

- 컴포넌트 간 코드를 공유하는 기존 방법: 고차 컴포넌트 또는 렌더링 Props
- 문제는 해당 방법을 이용하려면 구조를 변경해야 함
- 또한 중첩된 컴포넌트는 가독성을 해치고, 예기치 못한 오류를 발생 시킴
- 중복 코드도 발생하게 됨

### 12.4.4 Hooks

- 클래스 컴포넌트의 문제를 해결하기 위해 도입
- 가능한 일
    - 함수형 컴포넌트에 상태 추가
    - 라이프사이클 메서드를 사용하지 않고도 컴포넌트 라이프사이클 관리
    - 여러 컴포넌트 간 동일한 상태 관련 로직 재사용

## 12.5 상태 Hook

### 12.5.1 이펙트 Hook

### 12.5.2 커스텀 Hook

### 12.5.3 Hook 관련 추가 정보

### 12.5.4 Hook 장단점

- 장점
    - 더 적은 코드 라인
        - 코드를 라이프사이클별로 나누는 게 아니라, 관심사 및 기능별로 그룹화
    - 복잡한 컴포넌트 단순화
        - js의 클래스는 관리가 어렵고, 핫 리로딩과 함께 사용하기 힘들고, 경량화가 어려움
    - 상태 관련 로직 재사용
    - UI에서 분리된 로직 공유
- 주의점
    - Hook 사용 규칙 준수
    - 올바르게 사용하려면 상당한 연습이 필요 // ???
    - 잘못된 사용에 주의해야 함(ex. useCallback, useMemo)

### 12.5.5 Hook vs Class

## 12.6 정적 가져오기

- import module from ‘module’ 해서 가져오는 모듈은 정적으로 가져온 것
- 번들러를 통해 모듈 의존성에 번들링 됨. 정적으로 가져왔기 때문에 번들러는 초기 번들에 포함시킴
- js 엔진이 해당 모듈을 import 할 때 즉시 실행됨

## 12.7 동적 가져오기

### 12.7.1 로더블 컴포넌트

- Suspense

### 12.7.2 상호작용 시 가져오기

- 사용자 상호작용을 통해 컴포넌트를 가져옴

### 12.7.3 화면에 보이는 순간 가져오기

- lazy-loading 등

## 12.8 코드 스플리팅

- 적절한 시기에 정적 및 동적으로 임포트가 모두 가능하도록 코드를 최적으로 스플리팅 해야함

### 12.8.1 경로 기반 분할

### 12.8.2 번들 분할

- 번들 크기를 결정할 때 고려해야 할 지표?
    - FCP, LCP, TTI
- 초기 로딩 시 현재 페이지에서 우선순위가 높지 않은 코드를 요청할 때는 초기 페이지 렌더링에 코드와 분리해서 로드 추천

## 12.9 PRPL(Push Render Pre-cache Lazy-loading) 패턴

- Push: 중요한 리소스를 효율적으로 푸시하여 서버 왕복 횟수를 최소화하고 로딩 시간을 단축
- Render: 사용자 경험을 개선하기 위해 초기 경로를 최대한 빠르게 렌더링
- Pre-cache: 자주 방문하는 경로의 에셋을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄이고 더 나은 오프라인 경험을 제공
- Lazy-load: 자주 요청되지 않는 경로나 에셋은 지연 로딩
- Web
    - HTTP/1.1
        - keep-alive 헤더를 통해 새로운 HTTP 요청 전송 전까지 클라이언트와 서버 간 TCP 연결을 유지
        - res, req에 줄바꿈 문자로 구분되는 일반 텍스트 프로토콜 사용
        - 클라-서버 간 최대 6개의 TCP 연결만 가능. 이전 요청 완료 후에야 다음 요청 가능(HOL Blocking 발생)
    - HTTP/2
        - res, req를 더 작은 프레임으로 분할(헤더 프레임, 데이터 프레임)
        - 양방향 스트림 사용 ⇒ 단일 TCP 연결을 통해 양방향 스트림을 만들어 여러 개의 요청 및 응답 프레임을 동시에 전달 가능
        - 서버 푸시
            - HTTP 요청을 통해 매번 명시적으로 리소스를 요청하는 대신 서버가 리소스를 푸시하여 자동으로 추가 리소스를 전송
            - 클라이언트는 해당 리소스를 브라우저 캐시에 저장하고, 동일한 요청이면 서버에 요청하지 않고 캐시된 걸 사용
            - 단 서버 푸시는 HTTP 캐시를 인지 못 해서 다음 웹사이트 재방문 시에는 사용할 수 없음
            - 이 문제를 해결하기 위해 서비스 워커를 사용해서 해당 리소스를 캐시함
            - 개발자는 리소스에 preload 힌트를 추가해서 브라우저를 도울 수 있음
            - 해당 기능을 지원하지 않는 브라우저라면 왕복 횟수를 최소화하는 최적화된 빌드를 생성
- 해당 패턴은 초기 로딩 최적화에 중점을 두기에 초기 접근 경로가 완전히 렌더링 되기 전에는 다른 리소스를 로드하지 않음 ← 코드 스플리팅을 활용

## 12.10 로딩 우선순위

- preload는 TTI, FID 지표 최적화 시 유리함
- 상호작용에 필요한 리소스를 먼저 로딩하다가 FCP, LCP에 필요한 리소스(ex. 히어로 이미지 혹은 폰트)의 로딩이 지연되는 일은 피해야 함

### 12.10.1 SPA의 Preload

```jsx
const EmojiPicker = import(/* webpackPreload: true */ "./EmojiPicker");

// 실제 결과물에서는
<link rel="prefetch" href="emoji-picker.bundle.js" as="script" />
...
```

- 초기 렌더링 후 1초 이내에 표시되어야 하는 리소스에만 선별 적용하는 게 좋다.

### 12.10.2 Preload + async 기법

### 12.10.3 크롬 95+ 버전에서의 Preload

- preload 권장 사항
    - HTTP 헤더에 preload를 넣으면 모든 리소스보다 우선 로딩
    - 일반적으로 중간 레벨 이상의 우선순위를 가진 preload는 파서가 HTML을 처리하는 순서대로 로드되므로, HTML 시작 부분에 preload를 넣을 때 주의해야 함
    - 미리 로드되는 폰트는 <head> 태그 끝 부분이나 <body> 태그 시작 부분에 넣는 게 가장 좋음
    - 미리 로드되는 모듈을 가져오는 건 실제 스크립트가 먼저 로드/파싱되도록 해당 가져오기가 필요한 <script> 태그 다음에 위치해야 함
    - 이미지 preload는 기본적으로 우선순위가 낮으며, 비동기 스크립트 및 기타 낮은/최저 우선순위 태그와 관련하여 순서를 지정해야 함


## 12.11 리스트 가상화

- 현재 화면에 보이는 행만 동적으로 렌더링

### 12.11.1 윈도잉/가상화의 작동 방식

### 12.11.2 List 컴포넌트

### 12.11.3 Grid 컴포넌트

### 12.11.4 웹 플랫폼의 발전

- CSS의 content-visibility
    - auto로 설정하면 화면 밖 콘텐츠의 렌더링과 페인팅을 필요 시점까지 지연시킬 수 있음


## 12.12 결론

## 12.13 마치며

## 🗣️ 이야기거리

- HTTP 관련된 이야기 나와서 좋았어요. 이쪽도 공부해야 하는데…….
- 이전 회사 다닐 때 웹 성능 최적화 관련해서 스터디한 적 있었어요. 모던한 방법은 아니긴 했지만 재밌었던 기억이 있는데… 혹시 각자 적용해보신 최적화 있으신가용?