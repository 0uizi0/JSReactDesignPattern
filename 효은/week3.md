## 7.7 팩토리 패턴

- // 객체 생성 로직을 캡슐화하여, 객체를 생성할 때 구체적인 클래스의 인스턴스를 직접 만들지 않고, 대신 팩토리 메서드를 사용하여 객체를 생성함

    ```jsx
    // 직접 생성하는 방식
    const circle = new Circle() // Circle 객체를 직접 만듦
    
    // 팩토리 패턴 방식
    const shape = ShapeFactory.createShape('Circle'); // createShape 라는 팩토리 메서드를 통해 Circle 객체를 만듦
    ```

- 동적인 요소나 애플리케이션 구조에 깊게 의지하는 등의 상황처럼 객체 생성 과정이 복잡할 때 유용
- // 객체 생성의 책임을 팩토리에 위임함으로써, 코드의 유연성과 가독성을 높여주는 역할을 함
- // 첫 번째 방법과 두 번째 방법의 차이
    - 첫 번째
        - VehicleFactory 클래스가 하나만 존재하고, 거기서 car나 truck을 생성함. 넘겨주는 옵션(vehicleType의 값)에 따라 달라짐
        - 장점: 클래스 하나로 여러 종류의 차량을 만듦
        - 단점: 코드 복잡도가 올라감. 모든 차량을 한 팩토리에서 관리하면 과도하게 많은 책임을 가져가게 됨.
    - 두 번째
        - VehicleFactory의 서브클래스인 TruckFactory를 만들고 거기서 truck만 관리
        - 장점: 각 팩토리가 하나의 책임(특정한 종류의 차량만 생성)을 가지게 되어 코드가 더 명확해짐
        - 단점: 팩토리 클래스를 여러 개 만들어야 해서 새로운 종류의 차량을 추가할 때마다 새로운 팩토리를 만들어야 함

### 7.7.1 팩토리 패턴을 사용하면 좋은 상황

- 객체나 컴포넌트의 생성 과정이 높은 복잡성을 가지고 있을 때
- 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
- 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때
- 덕 타이핑같은 API 규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할 때. 또한 디커플링에도 유용함.

### 7.7.2 팩토리 패턴을 사용하면 안 되는 상황

- 애플리케이션의 복잡도가 증가함
- 객체 생성 과정을 인터페이스 뒤에 추상화하기 때문에 객체 생성 과정이 복잡할 경우 단위 테스트의 복잡성 또한 증가시킬 수 있음

### 7.7.3 추상 팩토리 패턴

- 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴
- 장점
    - 객체의 생성 과정에 영향을 받지 않아야 하거나 여러 타입의 객체로 작업할 때 좋음

## 7.8 구조 패턴

- 클래스와 객체의 구성을 다룸

## 7.9 퍼사드 패턴

- // 복잡한 시스템을 단순화하는 패턴. 여러 클래스나 복잡한 서브 시스템이 있을 때, 이들을 하나의 통합된 인터페이스로 묶어서 제공함. 즉, 서브 시스템의 복잡성을 감추고, 클라이언트가 서브 시스템의 세부 사항을 몰라도 간단하게 사용할 수 있도록 해줌.
- // 팩토리 패턴과의 차이점?
    - 팩토리 패턴은 객체 생성의 복잡성을 숨기고 싶을 때 사용 ⇒ 객체가 어떤 방식으로 만들어지는 알 필요 없고 단순히 객체만 필요할 때
    - 퍼사드 패턴은 복잡한 서브 시스템을 간단하게 사용할 수 있는 인터페이스를 제공하고 싶을 때 사용. 여러 클래스를 일일이 호출하는 대신, 퍼사드를 통해 한 번에 작업을 수행할 수 있도록 만들 때.

## 7.10 믹스인 패턴

## 7.11 서브클래싱

- 부모 클래스를 확장하는 자식 클래스를 서브 클래스라 함
- 서브 클래싱이란 부모 클래스 객체에서 속성을 상속받아 새로운 객체를 만드는 것

## 7.12 믹스인

- // 전통적인 객체 지향 언어는 다중 상속이 가능하거나 상속 개념이 강하게 자리 잡고 있기 때문에 믹스인도 상속과 유사한 방식으로 동작할 수 있음. 반면, 자바스크립트는 다중 상속을 지원하지 않기 때문에 믹스인을 **조합(컴포지션) 방식으로 구현**함. 상속 대신 필요한 기능을 복사해서 클래스에 넣는 방식.
- // 함수형 믹스인: 함수를 사용해서 기존 클래스에 기능을 추가할 수 있음.
- // 여러 클래스나 객체에 공통 기능을 복사해서 사용할 때 유용함.

### 7.12.1 장점과 단점

- 장점
    - 함수의 중복을 줄이고 재사용을 높임
- 단점
    - 프로토타입의 오염과 함수의 출처에 대한 불확실성을 초래

  ⇒ react에서도 고차 컴포넌트나 hooks의 사용을 장려함


## 7.13 데코레이터 패턴

- 믹스인과 마찬가지로 객체 서브클래싱의 다른 방법임
- 객체의 생성을 신경 쓰지 않는 대신 기능의 확장에 좀 더 초점
- 프로토타입의 상속에 의지하기보다는 하나의 베이스 클래스에 추가 기능을 제공하는 데코레이터 객체를 점진적으로 추가함
- // 기존 객체나 클래스에 동적으로 새로운 기능을 추가하는 패턴

## 7.14 의사 클래스 데코레이터

### 7.14.1 인터페이스

### 7.14.2 추상 데코레이터

## 7.15 장점과 단점

- 장점
    - 확장에 열려 있고 베이스 객체가 변경될 걱정 없이 사용할 수 있음
    - 수많은 서브 클래스에 의존할 필요도 없음
- 단점
    - 복잡도가 올라감
    - DX 불편

## 7.16 플라이웨이트 패턴

- 연관된 객체끼리 데이터를 공유하게 하면서 애플리케이션의 메모리를 최소화하려는 목적을 가짐

### 7.16.1 사용법

### 7.16.2 데이터 공유

### 7.16.3 전통적인 플라이웨이트 구현 방법

### 7.16.4 플라이웨이트로 변환하기

### 7.16.5 기본 팩토리

### 7.16.6 외부 상태 관리하기

### 7.16.7 플라이웨이트 패턴과 DOM 객체

### 7.16.8 예시: 중앙 집중식 이벤트 핸들링

## 이야기거리

- 이번 주에 나온 디자인 패턴 중 실무에서 사용해보신 게 있으실까요?
  저같은 경우에는 퍼사드 패턴을 사용해본 것 같아요. 특정 컴포넌트를 하나 만들어 두고, 외부에서 사용해야 하는 상황이었는데 해당 컴포넌트에서 A func, B func 같은 것을 export 해서 외부에서는 해당 함수만 사용하면 되도록 처리한 적이 있어요.
- 메모이제이션 활용 많이 하시는 편인가요?