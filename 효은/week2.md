## Chapter 05. 최신 자바스크립트 문법과 기능

### 5.1 애플리케이션 분리의 중요성

- 모듈형이란?
    - 잘게 분리된 모듈로 구성됨 ⇒ 의존성을 낮추어 애플리케이션의 유지 보수를 용이하게 만듦. 또한 한 부분의 변경이 다른 부분에 어떤 영향을 미칠지 쉽게 확인 가능
    - AMD, CJS, ESM 등이 있음

### 5.2 모듈 가져오기와 내보내기

- 모듈을 사용하면 각 기능에 맞는 독립적인 단위로 코드를 분리할 수 있음
- 코드의 재사용성을 높여 다른 애플리케이션에도 같은 기능을 적용할 수 있게 함
- type에 모듈을 명시하거나 nomodule이라는 속성을 통해 브라우저에서 모듈 유무를 알려줄 수 있음

### 5.3 모듈 객체

- 모듈을 객체로 가져오면 객체 하나로 여러 곳에서 사용이 가능

### 5.4 외부 소스로부터 가져오는 모듈

### 5.5 정적으로 모듈 가져오기

- 메인 코드를 실행하기 전 모듈을 다운로드, 실행함
- 초기 페이지 로드 시 많은 코드를 로드 ⇒ 성능상 이슈가 생길 수 있음

### 5.6 동적으로 모듈 가져오기

- import(url)로 사용 가능함
- 필요한 시점에만 로드함(lazy-loading)

### 5.6.1 사용자 상호작용에 따라 가져오기

### 5.6.2 화면에 보이면 가져오기

### 5.7 서버에서 모듈 사용하기

- type: module 이렇게 사용하는 것

### 5.8 모듈을 사용하면 생기는 이점

- 한 번만 실행된다
- 자동으로 지연 로드된다
    - defer를 사용하지 않아도 동일한 효과를 냄
- 유지보수와 재사용이 쉽다
- 네임스페이스를 제공한다
- 사용하지 않는 코드를 제거한다
    - tree shaking

### 5.9 생성자, 게터, 세터를 가진 클래스

- ES6 이후로 private class 추가됨
- 최신 js에서는 내부 멤버를 비공개로 정의할 수도 있음(#를 붙여서)

### 5.10 자바스크립트 프레임워크와 클래스

## Chapter 06. 디자인 패턴의 유형

### 6.1 배경

- 디자인 패턴은 공통 설계 구조의 핵심 요소를 이름 짓고 추상화하여 재사용할 수 있는 객체지향 설계를 만드는데 유용함
- 유용한 클래스와 인스턴스를 제공하여 각각의 역할과 협업, 책임의 분배를 실현
- 특정 객체 지향 설계의 문제나 이슈에 초점을 맞춤
- 어디에 적용될 수 있는지, 다른 설계 조건에도 부합하는지, 사용함으로써 얻는 장단점과 결과를 설명함

### 6.2 생성 패턴

- 객체 생성 방식은 객체를 생성하는 방법에 초점을 둠
- e.g) 생성자, 팩토리, 추상, 프로토타입, 싱글톤, 빌더

### 6.3 구조 패턴

- 객체 구성과 객체 간 관계를 인식하는 방법에 중점
- e.g) 데코레이터, 퍼사드, 플라이웨이트, 어댑터, 프록시

### 6.4 행위 패턴

- 객체 간 커뮤니케이션을 개선 혹은 간소화하는데 중점
- e.g) 이터레이터, 중재자, 관찰자, 방문자

### 6.5 디자인 패턴의 분류

## Chapter 07. 자바스크립트 디자인 패턴

### 7.1 생성 패턴(이후로 나오는 것들은 생성 패턴의 종류)

### 7.2 생성자 패턴

### 7.2.1 객체 생성

### 7.2.2 생성자의 기본 특징

- js의 클래스는 객체 탬플릿을 정의하고 캡슐화 및 상속을 구현케 함
- 클래스는?
    - 새 객체를 초기화하는 constructor()라는 이름의 메서드를 가지고 있어야 함
    - new 키워드로 생성자를 호출할 수 있음
    - 생성자 내부에서 사용된 this 키워드는 새로 생성된 해당 객체를 가리킴
- 단점
    - 상속이 어려워짐
    - 생성자로 객체를 생성할 때마다 내부 메서드를 새로 정의함
    - 인스턴스는 모두 동일한 함수를 공유해야 하므로 이 방법은 효과적이지 않음

### 7.2.3 프로토타입을 가진 생성자

- js에서 프로토타입 객체는 함수나 클래스 등 특정 객체의 모든 인스턴스 내에 공통 메서드를 쉽게 정의할 수 있게 함

### 7.3 모듈 패턴(이후로 나오는 것들은 모듈을 구현하는 방법)

### 7.3.1 객체 리터럴

### 7.3.2 모듈 패턴

- 비공개
    - 모든 패턴은 클로저를 활용해 ‘비공개’ 상태와 구성을 캡슐화 함
    - 공개 및 비공개 메서드와 변수를 묶어 전역 스코프로의 유출을 방지하고 타 개발자의 인터페이스와의 충돌을 예방함
    - 반환된 객체에 포함된 변수를 비공개하려면 WekMap()을 이용하면 됨

### 7.3.3 모듈 패턴의 변형

- 믹스인 가져오기 변형
    - 유틸 함수나 외부 라이브러리 같은 전역 스코프에 있는 요소를 모듈 내부의 고차 함수에 인자로 전달할 수 있게 함
    - ⇒ 전역 스코프의 요소를 가져와 맘대로 이름을 지정할 수 있음
- 내보내기 변형
- 장점
    - 이해하기 쉬움
    - 비공개를 지원
- 단점
    - 공개와 비공개 멤버를 서로 다르게 접근해야 함
    - 나중에 추가한 메서드에서는 비공개 멤버에 접근할 수 없음
    - 자동화 단위 테스트에서 비공개 멤버는 제외되고, 핫픽스가 필요한 오류를 고칠 때 복잡도를 높임

### 7.3.4 WeakMap을 사용하는 최신 모듈 패턴

- WeakMap 객체는 기본적으로 키가 약하게 유지되는 맵임 ⇒ 참조되지 않는 키는 GC의 대상이 됨

### 7.3.5 최신 라이브러리와 모듈

### 7.4 노출 모듈 패턴

- 모든 함수와 변수를 비공개 스코프에 정의하고, 공개하고 싶은 부분만 포인터를 통해 비공개 요소에 접근할 수 있게 해주는 익명 객체를 반환하는 패턴
- 장점
    - 코드의 일관성이 유지됨
    - 모듈 가장 하단에 위치한 공개 객체를 더 알아보기 쉽게 바꿈 ⇒ 가독성 향상
- 단점
    - 비공개 함수가 비공개 구현을 참조함 ⇒ 수정해도 함수가 변경될 뿐 참조한 구현이 변경되는 게 아님 ⇒ 비공개 함수를 참조하는 공개 함수를 수정할 수 없음
    - 비공개 변수를 참조하는 공개 객체 멤버 역시 수정 불가
    - ⇒ 기존 모듈 패턴보다 취약함

  ### 7.5 싱글톤

    - 클래스의 인스턴스가 오직 하나만 존재하도록 제한함
    - 싱글톤의 적합성
        - 클래스의 인스턴스는 정확히 하나만 있어야 하며 눈에 잘 보이는 곳에 위치시켜 접근을 용이하게 해야 합니다.
        - 싱글톤의 인스턴스는 서브클래싱을 통해서만 확장할 수 있어야 하고, 코드의 수정 없이 확장된 인스턴스를 사용할 수 있어야 합니다.
    - 정적 클래스와 차이점?
        - 싱글톤을 정적 인스턴스로 구현했다 해도 필요할 때까지는 리소스나 메모리를 소모하지 않도록 지연 생성할 수 있음
    - 단점?
        - 싱글톤임을 파악하기 힘들다
        - 테스트하기 힘들다
        - 신중한 조정이 필요하다

  ### 7.5.1 리액트의 상태 관리

    - 싱글톤 대신 Context API나 리덕스 같은 전역 상태를 이용해서 개발할 수 있음

  ### 7.6 프로토타입 패턴

    - 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴
    - 프로토타입의 상속을 기반으로 함
    - 장점?
        - 상속을 구현하는 쉬운 방법
            - Object.create는 다른 객체로부터 직접 상속할 수 있게 해주는 차등 상속과 같은 고급 개념을 쉽게 구현할 수 있게 해줌
        - 객체 내 함수를 정의할 때 복사본이 아닌 참조로 생성되어 모든 자식 객체가 동일한 함수를 가리킴 ⇒ 성능상 이점